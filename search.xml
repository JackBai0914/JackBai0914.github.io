<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[太极作品一：鲜艳的gif图]]></title>
    <url>%2F2020-06-04-taichi-gui.html</url>
    <content type="text"><![CDATA[据不完全统计，你大概欠着40篇想写的博客。 But anyway，来记录一下你用太极编写的第一个程序吧！ 成品展示： 在Windows环境下，用Taichi GUI生成连续图片，并用ffmpeg合成的gif图。 用taichi生成图片这个程序只用到了taichi的一些基本操作。包括一些基本函数和GUI的用法。 1234567891011121314151617181920212223242526272829303132333435363738394041424344import taichi as ti# initializationti.init (arch = ti.gpu)# Allocationn = 512# pixels = ti.var(dt=ti.f32, shape=(n * 2, n))pixels = ti.Vector(3, dt=ti.f32, shape=(n, n))PI = 3.1415926535898# Computation@ti.funcdef func (i:ti.f32, j:ti.f32, t:ti.f32, x:ti.i32, y:ti.i32): ii = (ti.cos(ti.cast(i, ti.f32))+1)*0.5 jj = (ti.cos(ti.cast(j, ti.f32))+1)*0.5 tt = (ti.cos(t)+1)*0.5 r = (ii-jj*2+tt+3) g = (-ii*2+jj+tt+3) b = (ii+jj-tt*2+3) while r&gt;1: r -= 1 while g&gt;1: g -= 1 while b&gt;1: b -= 1 pixels[x, y] = [r, g, b]@ti.kerneldef paint(t: ti.f32): for i, j in pixels: # Parallized over all pixels # pixels[i, j] = [i/n, j/n, (ti.cos(t)+1)*0.5] func(i/n*2*PI, j/n*2*PI, t/512*2*PI, i, j)gui = ti.GUI("Julia Set", res=(n, n))for i in range(512): paint(i) gui.set_image(pixels.to_numpy()) # gui.show() gui.show(f'frame/&#123;i:04d&#125;.png') # if i==100: # gui.show('test.jpg') 遇到的坑 init的时候，选gpu就好 震惊的发现，@ti.func函数的变量类型，由实参而非形参决定。换句话说，一个ti.i32的变量传入ti.f32的形参，它在函数里被用的时候，还是i32的。 gui.set_image()接受的参数有几种，详见API。但是接受Vector Tensor时，必须用$.to_numpy()$转化一步… gui.show()接受名称参数，$f’FILE_NAME/$为文件夹, ${i:04d}$可以设置输出格式。 ffmpeg的一些操作 ffmpeg已经下载在家里的电脑里了。或者看这里 图片转gif的神奇操作其实是和这位老哥学的。 图片转mp4: 1ffmpeg -framerate 60 -i ./frame/%04d.png -c:v libx264 -r 30 out.mp4 mp4转gif: 1ffmpeg -ss 00:00 -t 5 -i out.mp4 -vf &quot;fps=25,scale=320:-1:flags=lanczos,split[s0][s1];[s0]palettegen[p];[s1][p]paletteuse&quot; -loop 0 out.gif 总结gif还是很漂亮的～]]></content>
      <categories>
        <category>Graphics</category>
        <category>Taichi</category>
      </categories>
      <tags>
        <tag>Taichi</tag>
        <tag>GAMES201</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ByteCamp_day3_F]]></title>
    <url>%2F2020-05-03-ByteCamp-day3-F.html</url>
    <content type="text"><![CDATA[题目大意平面内有一个点集和一个矩形。选定矩形内一点，使得矩形绕它旋转后，覆盖过的点数最少 本质信息与套路解法代码12 解题收获]]></content>
      <categories>
        <category>Algorithms</category>
      </categories>
      <tags>
        <tag>CS</tag>
        <tag>Algorithms</tag>
        <tag>Problem Reports</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ByteCamp_day3_L]]></title>
    <url>%2F2020-05-03-ByteCamp-day3-L.html</url>
    <content type="text"><![CDATA[在贫瘠的草原上，寻找花的种子。 题目大意定义biggest_digit(A)为A在10进制下最大的一个位的值。 求A在经过n次 $A:=biggest_digit(A)%m$ 运算之后的值。 本质信息与套路 找规律啊，找一些不变的量啊。 这种题不是枚举玄学优化，就是DP。 解法代码12 解题收获]]></content>
      <categories>
        <category>Algorithms</category>
      </categories>
      <tags>
        <tag>CS</tag>
        <tag>Algorithms</tag>
        <tag>Problem Reports</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ByteCamp_day3_K]]></title>
    <url>%2F2020-05-03-ByteCamp-day3-K.html</url>
    <content type="text"><![CDATA[题目大意 本质信息与套路 本题中的限制，可以两两考虑矛盾。也可以只考虑限制点的合法性 解法代码12 解题收获]]></content>
      <categories>
        <category>Algorithms</category>
      </categories>
      <tags>
        <tag>CS</tag>
        <tag>Algorithms</tag>
        <tag>Problem Reports</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ByteCamp_day3_J]]></title>
    <url>%2F2020-05-03-ByteCamp-day3-J.html</url>
    <content type="text"><![CDATA[举步维艰。 题目大意 本质信息与套路解法代码12 解题收获]]></content>
      <categories>
        <category>Algorithms</category>
      </categories>
      <tags>
        <tag>CS</tag>
        <tag>Algorithms</tag>
        <tag>Problem Reports</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ByteCamp_day3_I]]></title>
    <url>%2F2020-05-03-ByteCamp-day3-I.html</url>
    <content type="text"><![CDATA[题目大意You are given a track of length L. On it there are N marbles at positions A1, A2 · · · , AN and N switches at positions B1, B2, · · · , BN , both of negligably small size. In the beginning, you direct each marble left or right and they all start moving at the constant speed of 1 in the given direction. When two marbles collide, they bounce off each other elastically, meaning that they continue moving in opposite directions at the same speed. If a marble collides with the beginning or end of the track it bounces off with the same speed in the opposite direction. Keep in mind that it takes exactly one second for a marble at position i to travel to the position i + 1 or i + 1, and it also takes exactly one second to travel from 1 back to 1while changing directions, or to travel from L back to L while changing directions. The goal is to have amarble on top of every switch. You need to find the minimum amount of time needed to achieve this. 本质信息与套路 转化反弹 解法代码12 解题收获]]></content>
      <categories>
        <category>Algorithms</category>
      </categories>
      <tags>
        <tag>CS</tag>
        <tag>Algorithms</tag>
        <tag>Problem Reports</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ByteCamp_day3_H]]></title>
    <url>%2F2020-05-03-ByteCamp-day3-H.html</url>
    <content type="text"><![CDATA[看见曙光。 题目大意Given a n*n grid that contains n coins, and the positions of the coins. Calculate the minimum number of moves (moving a coin to a 4-adjacent grid) to make the coins spread on every colomn and every row. 本质信息与套路解法代码12 解题收获]]></content>
      <categories>
        <category>Algorithms</category>
      </categories>
      <tags>
        <tag>CS</tag>
        <tag>Algorithms</tag>
        <tag>Problem Reports</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ByteCamp_day3_G]]></title>
    <url>%2F2020-05-03-ByteCamp-day3-G.html</url>
    <content type="text"><![CDATA[穿越晨雾。 题目大意给定A，不断复制自身得到无限串T。 给定字符串集S。求至少用其中的多少个串，才能拼成B，使得B不断复制自身后得到T。 本质信息与套路 先找出A的最小循环节a，这是我们要拼成的关键信息。 发现“S拼成了几个a”是无用信息。 $S_i$”从a的哪个位置开始，哪个位置结束”是关键信息。因为，这件事唯一决定了它该怎么被用，对答案有什么贡献。 建图求环 解法代码12 解题收获]]></content>
      <categories>
        <category>Algorithms</category>
      </categories>
      <tags>
        <tag>CS</tag>
        <tag>Algorithms</tag>
        <tag>Problem Reports</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ByteCamp_day3_D]]></title>
    <url>%2F2020-05-03-ByteCamp-day3-D.html</url>
    <content type="text"><![CDATA[在迷雾中前行。 题目大意在一棵树上，两个人轮流选点。先手目标为让自己选点的直径最小，后手目标为让先手选点的直径最大。求两人都采取最优策略时的答案。 本质信息与套路解法 先手取最后一个 如果有三个点构成直径的话，先手gg 后手取最后一个 如果有四个点构成直径的话，先手gg 代码12 解题收获]]></content>
      <categories>
        <category>Algorithms</category>
      </categories>
      <tags>
        <tag>CS</tag>
        <tag>Algorithms</tag>
        <tag>Problem Reports</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ByteCamp_day3_C]]></title>
    <url>%2F2020-05-03-ByteCamp-day3-C.html</url>
    <content type="text"><![CDATA[在迷雾中前行。 题目大意存在数组L，已知数组A满足$A_i = GCD(L_i, L_{i+1})。构造L。 算法定位解法用$A_i$左右的gcd取lcm，得到$A’_i$，可知后者为前者因数，后者满足条件为前者满足条件的充分条件。 代码12 解题收获]]></content>
      <categories>
        <category>Algorithms</category>
      </categories>
      <tags>
        <tag>CS</tag>
        <tag>Algorithms</tag>
        <tag>Problem Reports</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ByteCamp_day3_B]]></title>
    <url>%2F2020-05-03-ByteCamp-day3-B.html</url>
    <content type="text"><![CDATA[在迷雾中前行。 题目大意给定一个矩阵，每个元素为图中的一条边。 每次询问一个子矩阵（长宽比不超过3/2），求它构成的MST。 算法定位 MST是可合并的。 用ST表，利用子矩阵长宽的信息 解法代码12 解题收获]]></content>
      <categories>
        <category>Algorithms</category>
      </categories>
      <tags>
        <tag>CS</tag>
        <tag>Algorithms</tag>
        <tag>Problem Reports</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ByteCamp_day3_A]]></title>
    <url>%2F2020-05-03-ByteCamp-day3-A.html</url>
    <content type="text"><![CDATA[在迷雾中前行。 题目大意Given n (1 &lt;= n &lt;= 1000), k (0 &lt;= k &lt;= $\frac{n*(n-1)}{2}$), x (2 &lt;= x &lt;= 1000). Construct an n-element array, satisfying: All elements are smaller than $10^6$ There are exactly k unordered pairs of different indices (i, j) such that $|A_i-A_j| &gt;= x$ 本质信息 可以把数组分成不相干的一些部分，使得部分之间有贡献，部分中无贡献。 套路 增量构造！！！！ 解法代码12 解题收获]]></content>
      <categories>
        <category>Algorithms</category>
      </categories>
      <tags>
        <tag>CS</tag>
        <tag>Algorithms</tag>
        <tag>Problem Reports</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Certificate Verification]]></title>
    <url>%2F2020-04-28-decoder.html</url>
    <content type="text"><![CDATA[Every cerfificate offered by the SDSZ Mathematics Office has an unique code that satisfies certain cryptographical patterns. If you want to check whether or not your certificate is legitimate, download the program below and type in the code. Instruction for running decoder on Mac:Decoder_Mac 123450.Download the program.1.Open the terminal (google if confused).2.Go to the &quot;Downloads&quot; folder by typing in command &quot;cd Downloads&quot;.3.Give computer the permission to run decoder by typing in command &quot;chmod +x decoder_Mac&quot;.4.Run the decoder program by typing in command &quot;./decoder_Mac&quot;. Instruction for running decoder on Windows:Decoder_Windows 120.Download the program.1.Double click to run it.]]></content>
      <categories>
        <category>其他</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[CR633C]]></title>
    <url>%2F2020-04-23-CR633C.html</url>
    <content type="text"><![CDATA[题目大意Consider the infinite sequence $s$ of positive integers, created by repeating the following steps: Find the lexicographically smallest triple of positive integers (a,b,c) such that: $a⊕b⊕c=0$, where $⊕$ denotes the bitwise XOR operation. $a$, $b$, $c$ are not in s. Append $a$, $b$, $c$ to $s$ in this order. Go back to the first step. You have integer $n$. Find the n-th element of $s$. You have to answer $t$ independent test cases. 算法定位 Construction Recursion 解法代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;#include &lt;ctime&gt;#include &lt;cmath&gt;using namespace std;typedef long long ll;ll n, m;ll a, b, c;int main() &#123; ios::sync_with_stdio(false); int t; cin &gt;&gt; t; while (t -- )&#123; cin &gt;&gt; n; m = (n - 1) / 3 + 1; ll len = 1, bef = 0; while (m &gt; len + bef) &#123; bef += len; len *= 4; &#125; ll ord = m - bef - 1; a = len + ord; int r[4] = &#123;0, 2, 3, 1&#125;; ll weight = 1, sum = 0; while (ord) &#123; sum += weight * r[ord % 4]; ord /= 4; weight *= 4; &#125; b = len * 2 + sum; c = a ^ b; if (n % 3 == 1) cout &lt;&lt; a &lt;&lt; '\n'; if (n % 3 == 2) cout &lt;&lt; b &lt;&lt; '\n'; if (n % 3 == 0) cout &lt;&lt; c &lt;&lt; '\n'; &#125; return 0;&#125; 解题收获在考场上，你还算比较聪明：打表，找规律。 当找到规律以后，立刻将规律形式化，并想出最快的实现方法。]]></content>
      <categories>
        <category>Algorithms</category>
        <category>Construction</category>
      </categories>
      <tags>
        <tag>CS</tag>
        <tag>Algorithms</tag>
        <tag>Problem Reports</tag>
        <tag>Construction</tag>
        <tag>Recursion</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[线性基算法整理]]></title>
    <url>%2F2020-04-19-LinearBase.html</url>
    <content type="text"><![CDATA[线性基是向量空间的一组基，常用来解决子集异或一类题目的算法。 线性基的定义异或和设S为无符号整数集，定义其异或和 xor-sum(S) = $S_1 xor S_2 … xor S_{|S|}$ 张成设集合$T \subseteq S$，所有这样的子集$T$的异或和组成的集合称为集合$S$的张成，记作 $span(S)$。即，在$S$中选出任意多个数，其异或和的所有可能的结果组成的集合。 线性相关对于一个集合$S$，如果存在$S_j$使$span(S) == span(S$ $S_j)$，则称S线性相关。 线性基我们称集合$B$是$S$的线性基，当且仅当： $S \subseteq span(B)$ B是线性无关的 $|B|$称为线性基的长度。 线性基的构造方法构造一个普通的线性基已知集合S，其中每个元素均小于$2^m$。不失一般性的，对于每一个二进制位i，我们假设有B中有至多一个元素与其对应，我们称其为$b_i$。初始状态下，$b_i=0$，$\forall i \in [0, m)$。 每加入一个元素$x$，将其从大到小遍历每个二进制位： 12345for (int i = m - 1; i &gt;= 0 &amp;&amp; x; i --) if (x &gt;&gt; i &amp; 1) if (!b[i]) &#123;b[i] = x; break;&#125; else x ^= b[i];// "&gt;&gt;" will be processed prior to '&amp;' 构造一个有特殊性质的线性基易知，一个集合S可以有很多组等价的线性基。这促使我们思考，我们可否让构造出的线性基拥有更好的结构。 我们用类似高斯消元的方法，可以让线性基的关键位(有B中元素对应的位)只有一个元素为1. 123456789101112for (int i = m - 1; i &gt;= 0 &amp;&amp; x; i --) if (x &gt;&gt; i &amp; 1) &#123; if (!b[i]) &#123; b[i] = x; for (int j = i - 1; j &gt;= 0; j --) if (b[i] &gt;&gt; j &amp; 1) b[i] ^= b[j]; for (int j = m - 1; j &gt; i; j --) if (b[j] &gt;&gt; i &amp; 1) b[j] ^= b[i]; return ; &#125; else x ^= b[i]; &#125;//ATTENTION: those two "for" must not be switched 如果线性基的长度为m，那么写成矩阵的话，这个线性基就是对角矩阵$D_m$。 一般来说，我们都会构造有特殊性质的线性基。 线性基的合并合并只需要将一个线性基中的所有元素插入到另一个线性基中即可，时间复杂度为$O(m^2)$。 线性基的进阶性质方案数对于集合$S$及其线性基$B$，$\forall v \in span(B)$，异或和为v的方案数为$2^{|S| - |B|}$。 补充资料]]></content>
      <categories>
        <category>Algorithms</category>
        <category>LinearBase</category>
      </categories>
      <tags>
        <tag>CS</tag>
        <tag>Algorithms</tag>
        <tag>ALgorithm Summaries</tag>
        <tag>LinearBase</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CR635E解题报告]]></title>
    <url>%2F2020-04-19-CR635E.html</url>
    <content type="text"><![CDATA[题目大意Given $n$ numbers belonging to $[0, 2^m)$. For each $i \in [0, m]$, compute the number of ways to pick numbers, such that their xor sum has $i$ 1-bits in the binary representation (i.e., $popcount(xor_sum) = i$). Modulo the answer by 998244353. $n \leq 2*10^5, m \leq 35$. 算法定位 异或线性基 状压DP 神奇的状压DP优化方法 解法The Problem Statement should immediately reminds you of Linear Base. 问题被转化为了：对于所有i，用线性基能构造出的popcount(x)=i的x有多少个？将结果乘以$2^{n - x}$就是答案。 Trivial Algorithm 1Find $span(S)$，enumerate and popcount each element. Time Complexity: $O(2^x * m)$，where $x$ is the length of S’s Linear Base. Trivial Algorithm 2What if $x$ is too big? According to the feature of linear base, all the binary digit i in $x$ is only influenced by $b_i$. For the digit outside $x$, we can use bitmask DP to record their value. Combining Algorithm 1 and 2, we can solve all the cases. HZK’s Algorithmm=35？如果我们能将dp分成$S_1$，$S_2$两部分，各自的复杂度都是$O(2^{m/2})$，并且满足$S_1$对$S_2$有影响，$S_2$对$S_1$无影响，那么我们就可以解决问题。 $S_1$：枚举所有满足$i \geq m/2$且$b_i \neq 0$的$b_i$是否被选。将结果记录在$dp[number][mask]$中，代表“前$m/2$位的popcount为number，后m/2位的状态为mask的选法有多少个”。时间复杂度为$O(2^{m/2}*m)$ $S_2$：遍历$i \leq m/2$且$b_i \neq 0$的$b_i$，更新dp数组。时间复杂度为$O(2^{m/2}*m^2)$。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;ctime&gt;#include &lt;cstdlib&gt;#include &lt;vector&gt;#define TIME (double)clock()/CLOCKS_PER_SECusing namespace std;typedef long long ll;const int mod = 998244353;int popcount(ll x) &#123;if (!x) return 0; return (x&amp;1)+popcount(x&gt;&gt;1);&#125;int n, m;ll a[200020], pow2[200020];namespace LinearBase &#123; const int maxLen = 37; int num = 0, spare; ll b[maxLen]; void add (ll x) &#123; for (int i = m - 1; i &gt;= 0 &amp;&amp; x; i --) if (x &gt;&gt; i &amp; 1) &#123; if (!b[i]) &#123; num ++; b[i] = x; for (int j = i - 1; j &gt;= 0; j --) if (b[i] &gt;&gt; j &amp; 1) b[i] ^= b[j]; for (int j = m - 1; j &gt; i; j --) if (b[j] &gt;&gt; i &amp; 1) b[j] ^= b[i]; return ; &#125; else x ^= b[i]; &#125; &#125; int extract (ll x) &#123; int ans = 0; for (int i = 0; i &lt; m; i ++, x &gt;&gt;= 1) &#123; if (b[i]) &#123; &#125; else (ans *= 2) += (x &amp; 1); &#125; return ans; &#125;&#125; using namespace LinearBase;ll dp[2][maxLen][1&lt;&lt;16];ll fans[maxLen];ll pans[maxLen];void dfs (int id, ll x) &#123; if (id == m) &#123; pans[popcount(x)] ++; return ; &#125; dfs (id + 1, x); if (b[id]) dfs (id + 1, x ^ b[id]);&#125;int main() &#123; ios::sync_with_stdio(false); pow2[0] = 1; for (int i = 1; i &lt;= 200000; i ++) pow2[i] = pow2[i - 1] * 2 % mod; memset (b, 0, sizeof b); cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= n; i ++) &#123; cin &gt;&gt; a[i]; add (a[i]); &#125; if (num &lt;= 23) &#123; dfs (0, 0); for (int i = 0; i &lt;= m; i ++) cout &lt;&lt; pans[i] * pow2[n - num] % mod &lt;&lt; ' '; cout &lt;&lt; endl; return 0; &#125; spare = (1ll &lt;&lt; (m - num + 1)); dp[1][0][0] = 1; bool ter = 0; for (int i = 0; i &lt; m; i ++) if (b[i]) &#123; int v = extract(b[i]); for (int j = 0; j &lt;= num; j ++) for (int k = 0; k &lt; spare; k ++) &#123; dp[ter][j][k] = dp[ter ^ 1][j][k]; if (j) (dp[ter][j][k] += dp[ter ^ 1][j - 1][k ^ v]) %= mod; &#125; ter ^= 1; &#125; memset (fans, 0, sizeof fans); for (int j = 0; j &lt;= num; j ++) for (int k = 0; k &lt; spare; k ++) (fans[j + popcount(k)] += dp[ter ^ 1][j][k]) %= mod; for (int i = 0; i &lt;= m; i ++) &#123; (fans[i] *= pow2[n - num]) %= mod; cout &lt;&lt; fans[i] &lt;&lt; ' '; &#125; cout &lt;&lt; endl; return 0;&#125; 解题收获首先，这道题目让你温习了线性基的知识点。一点也不难写，但需要你注意一些细节： 线性基新加一位的时候别忘记return 线性基消元时注意顺序。先消自己，再消别人。 记住”x &gt;&gt; i &amp; 1”的写法呗。 其次，这道题目也让你对dp的状态有了更加灵活的思考。开大规模的状态(比如mask)是迫不得已的，因为他们彼此有影响，必须分离。但是有些时候，特殊的性质使得DP的有些变量仅存在单向的影响关系，或者有些变量彼此无关，此时可以考虑重新设计DP状态，利用无关的变量合并状态。特殊地，在这道题中，正解利用的是”线性基中无效位不会影响有效位，而且有效位之间互相无关”的性质，HZK利用的是“线性基中大的有效位不会影响小的有效位”的性质。]]></content>
      <categories>
        <category>Algorithms</category>
        <category>LinearBase</category>
      </categories>
      <tags>
        <tag>CS</tag>
        <tag>Algorithms</tag>
        <tag>Problem Reports</tag>
        <tag>DP</tag>
        <tag>LinearBase</tag>
        <tag>MeetinMiddle</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CR635D解题报告]]></title>
    <url>%2F2020-04-18-CR635D.html</url>
    <content type="text"><![CDATA[题目大意有$n$种标号为1到n的小球，每种有0-n个，初识个数未知。每次操作，输入标号i，交互库会增加一个标号为i的小球，并返回三元对triplet = [x, x, x]与straight = [x - 1, x, x + 1]的个数。请在n次操作内，求出每种小球的初始个数。 算法定位 交互题 构造题 解法思考核心线索：如何能通过询问组合得知一种球的个数？ 询问一个球两次。(第二次区分出了0/1的情况)通过triplet。 询问标号x，然后标号x + 1，然后标号x。即可得到x+2的个数。 因为$\Delta straight_i = a_{i-2}a_{i-1} + a_{i-1}a_{i+1} + a_{i+1}a_{i+2}$，在知道这四个变量中的任意三个时，即可解方程求出另一个。(重点：需要保证未知数的系数非零。) 在$a_{n-1} \neq 0$时，若只有$a_n$未知，则可以直接得出。 正解构造：依次询问n-1, n-2, …, 5, 4, 3, 1, 2, 1。 通过后三个可求出1和2的个数。 对于任意的x ($x \geq 1$)，我们已知$a_{x+1}$，$a_{x}$，以及之前的所有值。易知$a_{x + 1}\neq 0$。我们可以通过$\Delta straight_i = a_{x-2}a_{x-1} + a_{x-1}a_{x+1} + a_{x+1}a_{x+2}$求出$a_{x+2}$的值，递归下去。 代码123456789101112131415161718192021222324#include &lt;bits/stdc++.h&gt;using namespace std;int n, s1, s2, t1, t2, d1[105], d2[105], a[105];int main() &#123; cin &gt;&gt; n &gt;&gt; s1 &gt;&gt; s2; for (int i = n - 1; i &gt;= 0; i--) &#123; cout &lt;&lt; "+ " &lt;&lt; (i &gt; 2 ? i : i % 2 + 1) &lt;&lt; endl; t1 = s1; t2 = s2; cin &gt;&gt; s1 &gt;&gt; s2; d1[i] = s1 - t1; d2[i] = s2 - t2; &#125; a[1] = sqrt(d1[0] * 2); a[3] = d2[0] - d2[2] - 1; a[2] = d2[2] / (a[3] + 1); a[4] = d2[1] / (a[3] + 1) - a[1] - 2; for (int i = 5; i &lt;= n; i++) &#123; a[i] = (d2[i - 2] - a[i - 4] * a[i - 3]) / (a[i - 1] + 1) - a[i - 3] - 1; &#125; cout &lt;&lt; "!"; a[n]++; for (int i = 1; i &lt;= n; i++) &#123; cout &lt;&lt; " " &lt;&lt; a[i]; &#125; cout &lt;&lt; endl; return 0;&#125; 解题收获不要漫无目的地乱想题目…这道题的核心线索很明确，正解构造也就是基于核心线索而来的。而你在思考的时候，没有把它作为核心，导致没有想清楚所有的可能性。 你想出了失败的构造方法，要总结它失败在哪里。你想的方法的缺陷很显然：特定的值如果是零，你的方法就没戏了。所以，如果你能总结出在解straight方程的时候要让系数非零这个结论，你离正解的构造就很近了。]]></content>
      <categories>
        <category>Algorithms</category>
        <category>交互题</category>
        <category>Construction</category>
      </categories>
      <tags>
        <tag>CS</tag>
        <tag>Algorithms</tag>
        <tag>Problem Reports</tag>
        <tag>Construction</tag>
        <tag>交互题</tag>
        <tag>增量法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Oxford 印象]]></title>
    <url>%2F2020-04-17-Oxford-CS.html</url>
    <content type="text"><![CDATA[最近没事闲逛Quora&amp;CollegeConfidential，看了很多很多关于牛津的评价。还是做做记录吧，不然就都忘了。 In comparison to Stanford or MIT, how are Oxford and Cambridge in computer science? …To rephrase that last paragraph, as an undergraduate you have some of the top experts in the world available for teaching in lectures, as well as the supervision system (tutorials in Oxford) which is the best in the world (please note: 2 supervisions per week, for an hour only, including preparation 10+ hours, but not a full week). You get to think, aloud, too. So to try to summarize: my impression of MIT is that it teaches technologies and skills. Cambridge, on the other hand, introduces you to as many different important subjects as you can deal with, and although the exams are tough they are also somewhat forgiving, particularly for the diploma in my time. Should I apply to Cambridge or Oxford for computer science? The two are characterized by their similarities far more than their differences, and the computer science courses of Oxford and Cambridge are pretty similar in structure. It’s hard to make an especially wrong choice here. The most obvious difference is that Oxford has two joint honours degrees, Maths &amp; Computer Science and Computer Science &amp; Philosophy. Cambridge doesn’t offer any joint honours courses with computer science, but in your first year you can sit some papers from the Natural Sciences degree and/or a social psychology paper, or you can sit two maths papers your first year in the “Computer Science with Mathematics” choice. This structural difference might be important to you. For me, the lack of a Maths &amp; Computer Science course at Cambridge made it an easy choice to apply to Oxford, and this was also true for many other people doing this course that I’ve talked to. Another difference is the size of the departments. Cambridge takes around 90 undergraduates each year for Computer Science; Oxford takes about half of that (including the joint courses). As a consequence, Cambridge probably offers more courses/modules, simply due to the larger scale. On the flip side, the small size of the Oxford department gives it a quite cozy, friendly feel; it seems much more unified than the larger departments. One significant difference is the actual courses available. It’s a bit dangerous to choose a university because of one or two specific courses, since these things can change and the courses could vanish. With that said, Cambridge has a bunch of more applied/“soft” options (Bioinformatics, Business Studies, E-Commerce, “Economics, Law, and Ethics”, Software Engineering, etc.) which you won’t find at Oxford. Cambridge also seems to have quite a few hardware-focused courses (ECAD and Architecture, Human-Computer Interaction, Computer Vision, System-on-Chip Design, Mobile and Sensor Systems, etc.) which you won’t really find at Oxford either. By contrast, Oxford’s department is very theory-focused— far more so than most or maybe even all American departments, for instance. That’s not to say Cambridge doesn’t have theoretical courses as well (it does, and quite a few of them at that). But it’s something you might keep in mind when deciding between the two. But, of course, the academics are only one part of the picture. You should consider other factors too. I agree with the suggestion to visit the two if possible, and to also think about which college you’d apply to. I agree with Michael M. Ross that your college is the most important factor in your experience, simply because it’s the context in which most of your teaching and socializing will probably take place. But on the other hand, it’s pretty much impossible to predict what your college experience will be like. It’s also pretty hard to go wrong and you’ll end up loving whichever college you end up at. Because of that, I don’t think college choice is a very useful thing to consider that much. I wouldn’t worry about it unless you have specific concerns (want to play on a particular college sports team or something). The colleges at both universities are pretty comparable anyway. As I said at the beginning of this answer, Oxford and Cambridge are overall very similar. You need to decide between them somehow, so of course consider all the factors. At the same time, I don’t think it’s something worth spending too much time stressing over. Best of luck! What is it like to study computer science at Oxford University? It’s a mixed bag, in my opinion. I, like most of my classmates, started Oxford computer science straight after school at age 18, so it comprised my first three years of independence as an adult. Living away from home in a pleasant setting with like-minded people was great. I learned a lot outside my discipline just from conversations over tea, which I really valued. The people I was with were the most similar to me of any group I’d been in before, but the collegiate structure of the University means that one lives with others studying a wide range of subjects, which keeps conversations interesting. It’s common to stay up into the early hours of the morning having a heated debate over some issue (abortion, free will, etc). I think most of the standard positive points about university apply: I made good friends; I grew a lot personally, and so on. Oxford is also a great setting for all of this. The city is small enough to walk most places in well under ten minutes, and big enough that it feels like there are things going on other than the University. The actual degree in computer science, however, is pretty poor, in my opinion. The lectures suffer the widely-recognised problems that are inherent to the format, but the Department of Computer Science goes one step further and provides, in most cases, LaTeX beamer slides read out in a monotone voice by someone who may or may not actually understand what they are reading (we know this from asking questions which other students can answer but the lecturer can’t). The first year-and-a-bit of the course features one-on-two tutorials, the merits of which have been covered elsewhere, and which I also found valuable. Then, those tutorials are replaced by larger classes which range from “acceptable” to “total shambles”. In my second year I started the computer graphics course but quit after the classes turned out to be an absolute Comedy of Errors, with the teacher incapable of using even the simplest relevant techniques. For example, he couldn’t work out what matrices could be used to scale vectors! According to its own website, “Oxford’s intensive teaching style is intellectually challenging, and leads to a world-class education.” Not in the Department of Computer Science. In the third year of the degree there is a research project where students work with members of the Department on original research. Credit where it’s due: this is great. I’ve heard stories of supervisors not replying to emails for weeks, ignoring the students they’re responsible for, but that didn’t happen to me — my supervisors were extremely professional, and, to be honest, were probably more on top of my project than I was (although I of course did the work). Another issue with the degree itself is the price tag. In practical terms, this isn’t an issue (for the student, as long as they’re within the EU), because a student loan can cover the cost, and the terms ensure that students only ever pay the loan back at a rate they can afford. But charging £27,000 (about $42,000 as of July 2015) for a degree inexorably leads to it being viewed as a product, and I think it’s clear from the experiences I outlined above that the computer science degree represents unbelievably bad value for money. The fee works out to £375 per week, and I can’t see any way to reconcile that price with the quality on offer. A subtlety here is that Oxford computer science graduates are extremely employable, and earn a lot more money, on average, than those without a degree. But correlation doesn’t imply causation, and I think the employability has a lot more to do with being admitted by the University than it has to do with being taught by it. Overall, I think if you can get an offer, and you take it up, you’ll probably have a fun, rewarding, and memorable three years, but I think that’s in spite of the formal teaching provisions, not because of them. Without a doubt, studying Computer Science at Oxford has been the best experience of my life. Oxford consistently ranks top 10 in the world for CS. The course is amazing, the people are really fun and I’m going to make a ton of money. The academic course The 3 year Bachelor in CS course is incredibly well designed. It doesn’t bend to the latest fad or fashion, instead, Oxford students are taught the principles behind whatever technology we’re using. The idea is that if you need a new language, you can pick it up in an afternoon. (This was super helpful when I started at Palantir and needed to learn CoffeeScript straight away). Two-on-one tuition is the highlight of the Oxford experience: you meet with your incredibly knowledgable tutor on a weekly basis. In a tutorial, you explore the most interesting questions from that week and the tutor hones in on anything you don’t understand. (These expand to 10-person classes for specialist subjects.) Oxford teaches you computer science from day one and the course encompasses all facets of CS. It covers functional programming, assembly code, concurrent algorithms, machine learning, linear algebra, compilers, OOP and networks just to name a few [full list here]. Oxford didn’t waste my time on things I could learn myself. For example, there is no course on javascript or web development, there’s nothing on Objective-C or Swift. Instead, Oxford teaches you what closures, pointers, garbage collection and heaps are so that when you want to learn a language, you already understand all the concepts. At the end of the course, you can pretty much work wherever you want. The Sunday Times found that Oxford computer scientists “were earning an average of £43,895 six months after graduating” [Sunday Times article]. You can get a silicon valley internship in your first summer and my friends have ended up at Palantir, Google, Facebook, Quora etc. Life outside CS Oxford colleges are basically Hogwarts houses. I chose Magdalen, which accepts about 120 students a year (4 of whom study CS). They provide meals and accommodation and have thriving clubs &amp; societies. Magdalen is also stunningly beautiful. Terms are 8 weeks long. There are three terms in a year. That means you have a ridiculous amount of vacation each year. Unlike some American colleges, I have not been constantly subjected to tests that count towards my final grade. Exams only come at the end of the year and the first year doesn’t count. You have the freedom to do pretty much whatever you like as long as your tutor is happy with you. I chose to train with Oxford Modern Pentathlon and spent roughly 18 hours a week training at the sports centre. There’s student politics, journalism, music, drama, friendly-level sports and competitive university sports. Studying at Oxford is no more expensive than any other university in the country – in many ways it’s actually cheaper with amazing support from the university and colleges [see Fees and funding]. Without a doubt, studying Computer Science at Oxford has been the best experience of my life.Oxford consistently ranks top 10 in the world for CS. The course is amazing, the people are really fun and I’m going to make a ton of money. The academic course The 3 year Bachelor in CS course is incredibly well designed. It doesn’t bend to the latest fad or fashion, instead, Oxford students are taught the principles behind whatever technology we’re using. The idea is that if you need a new language, you can pick it up in an afternoon. (This was super helpful when I started at Palantir and needed to learn CoffeeScript straight away). Two-on-one tuition is the highlight of the Oxford experience: you meet with your incredibly knowledgable tutor on a weekly basis. In a tutorial, you explore the most interesting questions from that week and the tutor hones in on anything you don’t understand. (These expand to 10-person classes for specialist subjects.) Oxford teaches you computer science from day one and the course encompasses all facets of CS. It covers functional programming, assembly code, concurrent algorithms, machine learning, linear algebra, compilers, OOP and networks just to name a few [full list here]. Oxford didn’t waste my time on things I could learn myself. For example, there is no course on javascript or web development, there’s nothing on Objective-C or Swift. Instead, Oxford teaches you what closures, pointers, garbage collection and heaps are so that when you want to learn a language, you already understand all the concepts. At the end of the course, you can pretty much work wherever you want. The Sunday Times found that Oxford computer scientists “were earning an average of £43,895 six months after graduating” [Sunday Times article]. You can get a silicon valley internship in your first summer and my friends have ended up at Palantir, Google, Facebook, Quora etc. Life outside CS Oxford colleges are basically Hogwarts houses. I chose Magdalen, which accepts about 120 students a year (4 of whom study CS). They provide meals and accommodation and have thriving clubs &amp; societies. Magdalen is also stunningly beautiful. Terms are 8 weeks long. There are three terms in a year. That means you have a ridiculous amount of vacation each year. Unlike some American colleges, I have not been constantly subjected to tests that count towards my final grade. Exams only come at the end of the year and the first year doesn’t count. You have the freedom to do pretty much whatever you like as long as your tutor is happy with you. I chose to train with Oxford Modern Pentathlon and spent roughly 18 hours a week training at the sports centre. There’s student politics, journalism, music, drama, friendly-level sports and competitive university sports. Studying at Oxford is no more expensive than any other university in the country – in many ways it’s actually cheaper with amazing support from the university and colleges [see Fees and funding]. Studying for my MSc Software Engineering at Oxford University was awesome. I would assume the same would be true of the Computer Science programme, but my experience relates to just the MSc Software Engineering programme. Oxford University consistently ranks in ‘Top 10’ lists for Computer Science - e.g. No. 3 in the 2013 QS World University Rankings - Computer Science Most Popular in the QS World University Rankings by… — LONDON, May 7, 2013 /PR Newswire UK/ — (No.1 for Europe). I was taught by some of the leading experts of our field, including learning ‘Service Orientated Architecture’ from the CTO of a leading global web services company (WSO2) who takes a week out from his company to teach the MSc module at Oxford. I learned ‘Agile Methods’ from an expert Agile coach who flies in from New Zealand just to teach at Oxford. I learned how to ‘Design for Security’ from experts, researchers and innovators in the field. Each course was special in its own way. There is a good mix of experts from industry and academia. Class sizes are small (typically around 10-12 people), often with 2 or 3 lecturers or guest lecturers for each module. This gives amble opportunity to ask questions and talk through ideas. The MSc Software Engineering is a part-time programme, intended for professionals who already have some real-world experience in the field. It is common for students to fly over from the US and further afield to attend each module (10 modules + thesis make a MSc). Oxford tends to draw the best talent - both in terms of lecturers and students - which makes for modules covering cutting-edge methods and technology, and great in-class discussions and perspectives based on real world experience from a range of sectors. Oxford as a city is great for studying. There are many famous institutions such as the Oxford Union (with high-profile debates), many talks in the evenings on all kinds of topics throughout the academic week, and many atmospheric and historical pubs. Studying at Oxford means being part of an Oxford College. My college (Kellogg) is a hub of social activity, great food, and great people. I’ve met some fascinating people on the course, made valuable friends and connections, and have learned a number of new skills and technologies that I’ve already applied to various problems in various industries. Since finishing my 10 modules, I’ve moved to Canada and set up a technology consulting corporation. I mostly work remotely, but typically fly to visit clients in various parts of the world a few times a year for on-site visits (including the university itself). It’s hard for me to quantify the economic benefits to me of studying at Oxford, but I’m fairly sure that it has helped me gain clients and take on interesting projects, and has increased my earning potential. If I could turn back time, I would have applied to study my BSc at Oxford too. Is it a bad idea for American high schoolers to apply to Oxford as undergrads? I went from an American high school to an undergrad degree at Oxford, so I’ve thought about this a lot. In summary: maybe. It depends. There are some serious downsides to going to Oxford as an American: No financial aid. You can still take out student loans, including US government loans, but you’re ineligible for Pell grants and you won’t receive any scholarship money from the university. Top US universities, by contrast, have very generous financial aid policies.Inflexible course of study. You need to apply for a specific degree program, like a BA in History or an MPhys in physics, etc. In other words, you need to know what you want to major in when you apply, and it’ll be difficult or impossible to change that if you change your mind — depending on what you want to switch to, to switch courses you may need to start over as a first-year and possibly even reapply and reinterview. Many American high school students haven’t put serious thought into what they want to major in, so they’d be a bad fit for this system. No broad education. The liberal arts education you’d find in the US — a broad combination of requirements in the humanities and sciences intended to give everyone a well-rounded education — doesn’t exist at Oxford. Rather, you exclusively study your course of study. I did Maths &amp; Computer Science, so every single class I took was in maths or in computer science; there was not only no requirement but even no opportunity to take classes in things like English, economics, philosophy, etc. I think this is a shame.It’s harder to maintain connections as a student… Oxford has pretty long vacations (six weeks around each of Christmas and Easter, and then the long vac in the summer is three months), and if you go home to the States for these it can feel like a bit of a drag on your friendships. Your friends will be making plans, hanging out, etc. over the breaks, which you’ll miss out on, and if you get into a relationship it’ll put strain on that. My advice here in retrospect: don’t spend too much time at home, especially the Easter vac, which will be tremendously boring (your friends will return to college by two weeks in or so, leaving you with a month by yourself). Instead, try to aggressively make plans to be in the UK or traveling elsewhere.…and even harder after you graduate. After graduating, I moved to Silicon Valley to come work at Quora, but all of my friends remain in the UK, especially in London. I can now expect to see my college friends a couple times a year at most from here on out. This sucks. It also makes life after graduation a bit more isolating; while most of my recently-graduated coworkers came with a ready-made extended network of friends and acquaintances in the Bay Area, I pretty much had to start all over from scratch, which isn’t fun.You need to be more proactive with your career. Going from a US high school -&gt; UK undergrad is pretty rare, so you’ll have to worry about things you might not have otherwise. For example, if you want to go to a US graduate school, they place a higher emphasis on undergraduate research than UK universities do, and you’ll have to both 1) realize this yourself and 2) proactively work to overcome fewer opportunities being available. For me working in tech, the culture is totally different in the US from in the UK. So I had to 1) realize I should be doing internships during my summers, 2) realize when and how to apply for them, 3) realize what opportunities are available/“good”. Seems easy written like this, but this is the kind of thing people passively assimilate from their peers which you miss out on. In particular, 1) none of my friends were working after their first year, so it didn’t even occur to me to get an internship then, 2) I didn’t apply for things my second year until January/February when already things were filling/filled up, and when I did apply almost nobody interviewed me, 3) it wasn’t until my third year that I had any sense of this at all, vs just applying to random companies I had heard of. All of this is to say: studying in the UK as an American is rare, and you’ll have to do extra work to make up for it.There are plenty of great things about going to Oxford too, of course. I’m not sure I’d give a blanket recommendation either way. But if you’re considering it, you should keep these things in mind. How many hours can part-time and full-time Oxbridge students afford to spend on playing video games? It depends on your goals. I’m a final-year (although I could actually do another year if I wanted) computer science student and I spend less than 10 hours on university work, most weeks, and I’m (probably) working at a 2.1. (In my second year I worked like this and got 66%, a mid-2.1.) I’m awake for roughly 16*7 = 112 hours a week, so that leaves about 100 hours. If I so chose, I’m sure I could squeeze in almost as much gaming as I wanted next to my other activities, like eating, socialising, and learning things I actually care about. I, like Peter, think this would be a bit of a waste of the Oxford environment, but it’s perfectly doable. (Note to American readers: 2.1 here means an “upper second class”, not a GPA.)]]></content>
      <categories>
        <category>Oxford</category>
      </categories>
      <tags>
        <tag>Oxford</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CF635C解题报告]]></title>
    <url>%2F2020-04-16-CR635C.html</url>
    <content type="text"><![CDATA[题目大意Given a string $t$ of length $m$ ($m \leq 3000$), a string $s$ of length $n$ ($n \leq 3000$), and an empty string $a$. Perform a sequence of operations which belong to two type: Delete the first character of $s$ and add it at the front of $a$. Delete the first character of $s$ and add it at the back of $a$. Perform no more than $n$ operations. How many ways to perform such that $a$ ends up having $t$ as a prefix (answer divided by 998244353)? 算法定位 Sectional Dynamic Programming Dimension-Eliminating trick 解法Trivial DP solution$dp[cur][st][ed]$ Stands for “the number of ways to construct $t_{st, ed}$ with first $cur$ charasters”. For each $s_i$: ​ for all $ed == m$: $dp[i][st][ed]$ &lt;- $dp[i - 1][st][ed]$ ​ for all $t_{st} == s_i$: $dp[i][st][ed]$ &lt;- $dp[i - 1][st + 1][ed]$ ​ for all $t_{ed} == s_i$: $dp[i][st][ed]$ &lt;- $dp[i - 1][st][ed - 1]$ $\therefore$ This solution has $O(n^3)$ time complexity. Dimention EliminationAre there any relationship between those three dimentions? Actually, there’s a strong connection: $cur = ed - st + 1 + wasted$. If we can find a way to fit in the wasted characters into our current solution, then we can elimimate a dimention. Then, we find that all wasted characters are put after $t$. In another words, we are matching $t+”* \”$. All the wasted charasters can also be counted as $ed = 1$**, and then $cur = ed - st + 1$. $\therefore$ The solution falls into a normal sectional DP: $dp[st][ed]$ Stands for “the number of ways to construct $t_{st, ed}$ with first $(ed - st + 1)$ charasters”. For each $s_i$: ​ for all $t_{st} == s_i$: $dp[st][st + i - 1]$ &lt;- $dp[st + 1][st + i - 1]$ ​ for all $t_{ed} == s_i$: $dp[ed - i + 1][ed]$ &lt;- $dp[ed - i + 1][ed - 1]$, which has $O(n^2)$ time complexity. 代码12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;cstdlib&gt;#include &lt;ctime&gt;using namespace std;typedef long long ll;const int mod = 998244353;string s, t;int n, m;ll dp[3030][3030];int main() &#123; ios::sync_with_stdio(false); cin &gt;&gt; s &gt;&gt; t; n = s.size(), m = t.size(); s = " " + s; t = " " + t; for (int i = m + 1; i &lt;= n; i ++) t += '*'; for (int i = 1; i &lt;= n; i ++) if (s[1] == t[i] || t[i] == '*') dp[i][i] = 2; for (int gap = 1; gap &lt; n; gap ++) for (int i = 1, j = i + gap; j &lt;= n; i ++, j ++) &#123; char c = s[gap + 1]; if (c == t[i] || t[i] == '*') (dp[i][j] += dp[i + 1][j]) %= mod; if (c == t[j] || t[j] == '*') (dp[i][j] += dp[i][j - 1]) %= mod; &#125; ll fans = 0; for (int j = m; j &lt;= n; j ++) (fans += dp[1][j]) %= mod; cout &lt;&lt; fans &lt;&lt; endl; return 0;&#125; 解题收获这道题你考场上花了两个小时…还是没想到DP的优化方法。或者说，其实你都没有看清楚，这其实是一个DP优化问题。这要让你警醒啊，看问题要看本质，想解法才能利用你之前的经验 (之前解决本质类似的题目的经验)。 你考场上一直在想“枚举前后分界点”的方法，殊不知，这是一个没有意义的维度：在哪里分界没关系，只要构成了t的同样的字串，对答案的挺想影响就都是一样的。所以设计dp状态的时候，要找对答案有意义的维度。 你其实早就意识到“前缀是t”而不是“字串是t”是这道题目的关键。但是你就是没有想到，这个性质可以用来把wasted的字符加入区间的考虑当中，以消去一个维度。]]></content>
      <categories>
        <category>Algorithms</category>
        <category>DP</category>
        <category>Sectional DP</category>
      </categories>
      <tags>
        <tag>CS</tag>
        <tag>Algorithms</tag>
        <tag>Problem Reports</tag>
        <tag>DP</tag>
        <tag>Dimension-Eliminatating Tricks</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CR635B解题报告]]></title>
    <url>%2F2020-04-16-CR635B.html</url>
    <content type="text"><![CDATA[题目大意Given $n_r$ red stones, $n_g$ green stones, and $n_b$ blue stones, each of which has a weight ($1 \leq w \leq 10^9$). Find a red stone, a green stone, and a blue stone, such that $(w_r - w_g)^2 + (w_g - w_b)^2 + (w_b - w_r)^2$ is minimized. 算法定位 (generally speaking) Functional Optimization task Brutal Force Improvement (wrong) Greedy 解法Feature 1 : If $w_r$ and $w_g$ are fixed, we can find optimal $w_b$ in $O(log_n)$ time. (Not useful in the standard solution) Feature 2: Since the order of r, g, b has only six circumstances, we can enumerate them. Feature 3: Suppose $w_r \leq w_g \leq w_b$, with fixed w_r, the smallest $w_b$ must be the optimal one, because $w_b$ always contribute to the answer positively. $\therefore$ We enumerate the order, enumerate the small weight, find the least middle weight, and find the least large weight. 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;cstdlib&gt;#include &lt;ctime&gt;using namespace std;typedef long long ll;int r, g, b;ll rl[1000010];ll gl[1000010];ll bl[1000010];ll fans = 0;ll sqr (ll x) &#123;return x * x;&#125;ll calc (ll a, ll b, ll c) &#123;return sqr(a - b) + sqr(b - c) + sqr(c - a);&#125;void solve (int r, int g, int b, ll *rl, ll *gl, ll *bl) &#123; int ptg = 1, ptb = 1; for (int i = 1; i &lt;= r; i ++) &#123; while (ptb &lt; b &amp;&amp; bl[ptb] &lt; rl[i]) ptb ++; ll mid = (rl[i] + bl[ptb]) &gt;&gt; 1; while (ptg &lt; g &amp;&amp; abs (gl[ptg] - mid) &gt;= abs (gl[ptg + 1] - mid)) ptg ++; fans = min (fans, calc (rl[i], gl[ptg], bl[ptb])); &#125;&#125;int main() &#123; ios::sync_with_stdio(false); int t; cin &gt;&gt; t; while (t -- ) &#123; fans = 1ll&lt;&lt;62; cin &gt;&gt; r &gt;&gt; g &gt;&gt; b; for (int i = 1; i &lt;= r; i ++) cin &gt;&gt; rl[i]; for (int i = 1; i &lt;= g; i ++) cin &gt;&gt; gl[i]; for (int i = 1; i &lt;= b; i ++) cin &gt;&gt; bl[i]; sort (rl + 1, rl + r + 1); sort (gl + 1, gl + g + 1); sort (bl + 1, bl + b + 1); solve (r, g, b, rl, gl, bl); solve (r, b, g, rl, bl, gl); solve (g, r, b, gl, rl, bl); solve (g, b, r, gl, bl, rl); solve (b, g, r, bl, gl, rl); solve (b, r, g, bl, rl, gl); cout &lt;&lt; fans &lt;&lt; endl; &#125; return 0;&#125; 解题收获这道题给你最大的收获，就是常数个变量的大小关系可以$O(C!)$枚举，尤其是在大小关系确定以后可以简化解法(specifically，出现了新的单调性质)的时候。 这样存在着显然的枚举方法的最优化题目，一般都是要找到一些在枚举中存在的贪心性质(m越接近s和l的中点答案越优，l越小答案越优)和单调性质，然后简化枚举。在更难的题目中，有些贪心和单调性只在特定的枚举顺序中才存在。 这道题你考场上FST了…单调性不能乱猜，你在探索算法，而不是在浑水摸鱼。]]></content>
      <categories>
        <category>Algorithms</category>
        <category>Optimization</category>
        <category>Greedy</category>
      </categories>
      <tags>
        <tag>CS</tag>
        <tag>Algorithms</tag>
        <tag>Problem Reports</tag>
        <tag>Greedy</tag>
        <tag>Optimization</tag>
        <tag>Monotonicity</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CR635A解题报告]]></title>
    <url>%2F2020-04-16-CR635A.html</url>
    <content type="text"><![CDATA[题目大意给定一颗n个节点，以1为根的树。选择k个特殊点，使得$sum_{i=1}^{k}$(第i个特殊点到根的路径上的普通点个数)最小。 算法定位 树上选点集的问题 对答案的贡献与路径有关 每个点的状态对其子树内的点的贡献有影响 解法发现贪心性质：任何一点的子孙的贡献一定不劣于其本身的贡献。 $\therefore$ 得到最优方案的性质：点i在方案中时，其子树内所有节点一定也都在方案中。 上述性质可以用来计算点与点之间的所有影响。 $\therefore$ 得到每个点的贡献为：$distance - number$ 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;cstdlib&gt;#include &lt;ctime&gt;#include &lt;queue&gt;using namespace std;typedef long long ll;int n, k;int point[200020], te = 1, par[200020];struct e &#123;int to, next;&#125; edge[2000020];void add (int u, int v) &#123; te ++; edge[te].to = v; edge[te].next = point[u]; point[u] = te;&#125;ll sum[200020], num[200020], pans[200020];void dfs (int x) &#123; // cerr &lt;&lt; "dfs " &lt;&lt; x &lt;&lt; endl; num[x] = 1; for (int e = point[x]; e; e = edge[e].next) &#123; int to = edge[e].to; if (to == par[x]) continue ; par[to] = x; sum[to] = sum[x] + 1; dfs (to); num[x] += num[to]; &#125;&#125;int main() &#123; ios::sync_with_stdio(false); cin &gt;&gt; n &gt;&gt; k; for (int a, b, i = 1; i &lt; n; i ++) &#123; cin &gt;&gt; a &gt;&gt; b; add (a, b); add (b, a); &#125; sum[1] = 1; dfs (1); for (int i = 1; i &lt;= n; i ++) pans[i] = sum[i] - num[i]; sort (pans + 1, pans + n + 1); ll ans = 0; for (int i = n; i &gt; n - k; i --) ans += pans[i]; cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125; 解题收获树上选点最优化的问题，肯定不是randomly选，而是肯定存在着一些性质，使得选点有规律可循。规律有可能是对一个点和其子树的某些限制，就像是这道题一样。找到性质以后，问题就可以用贪心或者树形动态规划解决。 从另一个角度看，每个点都对答案有贡献，难点在于如何处理点之间的影响。在本题中，可以通过贪心性质来计算出点之间的影响。]]></content>
      <categories>
        <category>Algorithms</category>
        <category>Tree</category>
        <category>Greedy</category>
      </categories>
      <tags>
        <tag>CS</tag>
        <tag>Algorithms</tag>
        <tag>Problem Reports</tag>
        <tag>Tree</tag>
        <tag>Greedy</tag>
        <tag>Optimization</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces Diary]]></title>
    <url>%2F2020-04-12-CFRecording.html</url>
    <content type="text"><![CDATA[不想再拖了。CF上红名不难，难的是在心中点燃火焰。开始吧。 Initial Rating: 2161 2020.4.12 CR633 Div 1 Ranked 534 out of 1392 Rating: (+1) 2161 -&gt; 2162 总结 从过程上看，发挥中等。因思维生疏而导致想A (观察结论题) 和B (图论思维题)的时间过长；因手指生疏而导致写A错了三次 (本质也是没想清)，写C (找规律题)写得很复杂。 等级分的变化比较让我感到安慰。这说明，我只要正常发挥，稳定的做出该做的(三道)题，等级分是不会下降的。不过想要上红，一是要增加思考速度+手速，二是要积极思考D。不做出D，是很难上红的。 2020.4.15 CR635 Div 1 Ranked 1338 out of 2619 Rating: (-106) 2162 -&gt; 2056 12345意料之中的难受。也是久违的。你的思路十分闭塞。思考问题的时候，已经不再能抓住本质。可我还能看得见光。 我会好好睡觉，戒掉使人变得愚钝的恶习，我会重新开始思考。 这一切都还来得及。我不会放弃。]]></content>
      <categories>
        <category>Competitions</category>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>CS</tag>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[博客操作指南：域名，hexo，本地存储结构]]></title>
    <url>%2F2020-02-09-%E5%8D%9A%E5%AE%A2%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97.html</url>
    <content type="text"><![CDATA[启用博客啦！记录一些操作的步骤，以免以后忘记。 1.域名相关域名从阿里云平台购买。需登录阿里云平台进行续费和解析等操作。 域名解析我在阿里云上注册了域名：simulated-anneal.info，我想将其解析到我在github上的主页：jackbai0914.github.io。 将域名解析到http://jackbai.github.io上，需要添加两条解析： 先添加一个CNAME记录类型，主机记录写@，后面记录值写上http://jackbai0914.github.io 再添加一个CNAME记录类型，主机记录写www，后面记录值也是http://jackbai0914.github.io 这样别人用www和不用www都能访问网站（其实www的方式，会先解析成http://jackbai0914.github.io，然后根据CNAME再变成[simulated-anneal.info](simulated-anneal.info)，即中间经过一次转换）。 A记录是直接解析到空间IP地址；CNAME是解析到别名；MX是电子邮件系统发邮件时根据收信人的地址后缀来定位邮件服务器，是设置企业邮箱的;NS是指DNS,用默认的就行,一般不用修改；TXT一般指为某个主机名或域名设置的说明，是企业邮箱的辅助设置。 然后还需在github的库中进行一步操作： 在master分支下创建名为“CNAME”的文件。 将内容编辑为“simulated-anneal.info”，即想要绑定的域名。 在settings中，将Custom domain改为simulated-anneal.info。 这一步将github的主页重定向到了simulated-anneal.info上。但是博主目前还不理解这一步的目的…. 2.hexo常用命令在终端中用hexo命令，可以进行本地编辑博客，生成静态网页，部署博客到github上等操作。 1234567891011121314hexo new post &lt;title&gt; #新建名为&lt;title&gt;的文章，存储在source/_posts中hexo new page &lt;title&gt; #新建名为&lt;title&gt;的网页，存储在source中hexo new draft &lt;title&gt; #新建草稿，存储在source/_drafts中hexo new draft &lt;title&gt; #新建草稿，存储在source/_drafts中hexo publish [layout] &lt;title&gt; #将文件移到source/_posts中hexo generate #生成静态网页hexo generate --watch #监视文件变动hexo deploy #部署网页至github上hexo server #启动网页预览hexo server -p 2333 #将预览端口改为2333hexo clean #清除缓存，网页正常情况下可以忽略此条命令。执行该指令后。会删掉站点根目录下的public文件夹。明白了吧，public即存储生成的静态网页。hexo deploy --generate #在生成完毕后自动部署网站 3.本地存储结构 sources：修改文章和博客结构的地方。 themes：存储博客外观主题的地方。 NexT/_config.yml：外观主题的settings。 scaffolds：文章模版库。 public：存储生成的静态网页的地方，一般不要修改。 _config.yml：博客settings。]]></content>
      <categories>
        <category>其他</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[宾夕法尼亚大学 访校印象]]></title>
    <url>%2F2019-08-27-UPenn.html</url>
    <content type="text"><![CDATA[基本信息学校名称：University of Pennsylvania 位置: Philadelphia, PA 19104 排名：综合性大学排名第8（2018 US News） 在校生人数：21, 826 录取率：9.3% （2017） 国际生比例：6.6% 学费（不含食宿）：45, 556 课堂大小：83%的课堂少于30人 SAT：阅读 680-750；数学 690-770（2017） ACT：32-35（2017） 托福：100 （最低要求80） 校园环境宾大的校园不大不小，主要建筑之间的距离不远。建筑的主要色调是红色，风格比较古老。我们沿着Locust Walk一路走，环境很好，各个建筑就散布在周围。 我们先到了学校的图书馆Van pelt。里面学生不多，但是看起来都在安静，认真地学习。学生用的电脑设备很好，我看到了一个学生在用带弧形的双屏读论文写报告。从图书馆出来，我们能看见著名的纽扣和富兰克林的雕塑。 走到Locust Walk的尽头就来到了Warton商学院的位置。这栋建筑从外面看不显眼，但这是宾大的核心，是排名第一的商学院。我们正好赶上了2020届新生的入学仪式，发现Warton的各个Cohert竟然都是以货币单位命名的… 学术能力：寻问招生官从宾大以后的学校，我都有机会参加AO的information session或者现场找AO问问题。我第一次主动找招生官，表现的还是比较局促。之后要多问一些问题，对每个问题都有一些跟进，尤其是在自己喜欢的学校。 我首先询问了关于计算机专业的问题：是否有CS相关的非CS专业？AO告诉我是没有的。然后他给我仔细介绍了学生如何选择多个自己喜欢的专业：1/3的宾大学生都会选择major + minor的形式。而对于计算机，大部分人都会放在minor的位置，作为自己研究其他专业的一个工具。major的课程需要完成core的30门课程，而minor的课程只有十几门必修课。 进一步地，CS的专业在文理学院和工程院都有开设。一般人minor的都会是文理学院的那一个，它可能深度较浅但是较广。如果major工程院的CS专业，AO说，那很少有人会再minor其他的专业，因为工程院对CS对major的要求会比较高。 申请相关我也询问了招生官关于申请的问题。 123Q: 申请中什么最重要？A: AO传递的最主要的信息是，out-of-classroom与学术能力一样重要；Show us who you are是申请最主要的目标。 123Q: 活动列表应该怎样安排？A: 写对我影响最大，最重要的活动。当然，我也应该考虑到，这些活动group together以后会给招生官展现怎样的自己。最后，多余的活动也可以作为补充信息，做成resume交上去。 额外信息12345678910111213141516171819202122Q：能评价下费城是个怎样的城市吗？Lynn：文化氛围比较浓厚，城市中心有很地标性的建筑。虽然建筑风格比较老，玩乐也不像纽约那么丰富，但是该有的娱乐设施都有，能找到好吃的餐馆和KTV。整个城市的设计感觉会和国内比较像：比较紧凑不需要车，不过活动半径并不是特别大。Q：那学校的人文环境怎么样？Ni Ruoyang：因为是一个职业型（Pre-professional）大学，大家都想去沃顿，所以几乎没有人文环境。很多社团的运作都很商业化。刘奕麟：在宾大很容易会把自己禁锢在商业生活中。其实校园还是很多元的，想找肯定能找到人文氛围，也有学生互相辩论聊天地、聊政治的社团。Q：学校的强势学科有哪些？刘奕麟：沃顿有很多业界中最好的教授，所有人都争取在大四毕业前抢到最好的教授，管理的老师。文理院里面，宾大的经济和政治学挺强的。Q：学校除了商科以外，还有什么别的强势科目吗？只有商科好是一个误区吗？Lynn：宾大肯定是以商业为主。不可否认的是，我们学校的文理学院还是比较强的，文学和艺术史也比较强。在学校进来之后能申请双学位（Dual Degree），很多非商科的人也会选择商科作为第二学位。大一入学前就要申请的双学位项目有M&amp;T，Huntsman。这种双学位项目出来发展也很好的。Q：学校的必修课和选修课有哪些？刘奕麟：学校的体育课程不算分。要求的话和别的大学类似，分通识课和专业课。毕业要完成通识课，7个不同科目型的要求（Sectors），还有专业课及自由选修课。Q：平时课业压力大吗？Ni Ruoyang：在沃顿，课业并不会过于繁重，会根据大家的表现给分（Grade on a Curve）。沃顿的压力可能不在他们的课业难度上，课堂上会有很多以小组为单位进行的案例研究。这样的实战案例通常会占用很大的时间。刘奕麟：文理院的课业压力还是蛮大的。学校的数学教学比较差。因为注重研究，所以教学质量不一定好，很多老师不会怎么教学生。不过总体来说，你的时间付出和你收获的知识是成正比的。作者：Panopath过来人链接：https://www.zhihu.com/question/24297668/answer/350786305]]></content>
      <categories>
        <category>College Application</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[哥伦比亚大学 访校印象]]></title>
    <url>%2F2019-08-25-Columbia-University.html</url>
    <content type="text"><![CDATA[总结感觉上，哥大是一个精致，古典与现代结合的学校。地理位置优越，生活便利；工科教授的水平一流，学生水平，工程资源一般；需要主动利用资源。 总体感觉挺好的。也有朋友和父母熟人在旁边。只是在最繁华的市中心度过4年，不知道是否能保持学术的初心？ 校园环境学校坐落在纽约市中心，曼哈顿岛的中部，大约在110-120街区。中心是一个图书馆和一个大草坪，还有一个圆顶式建筑。吉祥物是狮子，不过实在有点瘦… 学校占地面积小。不过教学楼不仅在“校区”里，而是和城市融合。工学院的楼(Science Building)比较新。 据学长说，吃饭的地方很多，中餐很好。生活很方便，“开学背个电脑去就完事儿了”。 工学院的楼下有独立的咖啡厅。走过的时候，看见两个学生安静的一起坐在那里指尖飞舞。一杯咖啡，一个并肩探索的同学，在这里待一整天，也挺让人安心的。 学术能力按学长的话说，CS专业的学生普遍不是很厉害(厉害的都去MIT&amp;Stanford&amp;Princeton了)，但是教授很厉害(包括几个图灵奖+算法导论的作者)。可以跳课，可以修研究生课程；可以上上数学系的课，因为哥大纯数也挺好。 学长指出哥大的CS偏向理论。这其实挺好(比宾大好多了)，毕竟精通理论是之后做事情的必要条件。 哥大的人文Core对于工程院的学生选修，但是大部分同学还是会选一些。包括一些很好的通识课程，能让我浅层次地了解一些历史，哲学的知识。]]></content>
      <categories>
        <category>College Application</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[一道划痕]]></title>
    <url>%2F2019-08-08-%E5%8F%8D%E6%80%9D.html</url>
    <content type="text"><![CDATA[现在的状态，不能支撑你到达彼岸。 你变成了一个爱偷懒的人。之前跑的太累了是你的借口，于是现在就“暂时性”的放松。你不知道申请是你的最后一搏吗？没有了锐气，斗志和状态，你什么都不是。你是很努力的奔跑过。可是这不代表你现在就有休息的权利。冲刺的时候休息。你会发现那些弱智的同学也能超过你。这不可怕吗？ 你像以前一样无视规矩。可是，你难道分不清哪些是为自己好吗？你欠下DDL真的不羞愧吗？一次次的保证，真的不觉得以后会后悔？你连计划，都不会定了。你这样下去，完蛋了。 还能记起来斯坦福的梦吗？ 热闹的小宿舍，简朴的小房间；像海绵一样的作业，不Carry不爽课堂；做宿舍里第一个起床的人，静听着开水的滚沸和隔壁传来的琴声；清晨6点钟的阳光，Dry Lake旁的落日；性情随和，却对数学嗅觉敏锐的华裔同学，还有，笑容带着酒窝的那个女生…… 这些回忆，我已许久未曾想起。它们闪光的表面也蒙上了灰尘。这也很正常吧？斯坦福啊，对它感兴趣的同学还不够多吗？我是自作多情了，参加了个夏校，就以为发生了什么不得了的事，造就了我们的缘分。可事实是，痴迷斯坦福的人成千上万；99%的人做后都是抱着痛心离开，片面的讲成为失败者。我呢，大不了就是他们之一。 可是，我为什么又觉得自己不平常呢？每个人都能看到加州六点的晨雾吗？每个人都能在那些红色的房子里，做着assignments兴奋得发抖吗？每个人都会在营里认识几个忘不了的朋友吗？ 真是可笑。剥去执念，我竟真的找不到自己追求的方向了。以后会后悔的。我可不想知道这是一种什么样的感觉，失败者。 从糊涂的梦里醒过来吧。你还有机会，走向光明。]]></content>
      <categories>
        <category>其他</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[[Codeforces]CR576 比赛记录]]></title>
    <url>%2F2019-08-03-Codeforces-CR576.html</url>
    <content type="text"><![CDATA[Codeforces Round #576 (Div. 1)1. General Info Problem: ABCD solved, EF unread. Ranking: 167 out of 662. Rating: 2179 -&gt; 2221 (+42). Summary: Mistakenly understood A at first, and wasted two submissions. Solved C, a constructive task based on Independent Set and Node Matching. Wasted too much time on D, a brute force with a trivial feature. 2. ProblemsA. MP3Statement: Given n intergers, calculate the maximum numbers of integers we can get by choosing m consecutive values inputed. Tutorial: In the contest, I used Two Pointers to go through the sorted sequence. Yet, we can transformed the array into value-indexed form and calculated the prefix. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cmath&gt;#include &lt;cstring&gt;#include &lt;ctime&gt;#include &lt;vector&gt;using namespace std;typedef long long ll;int n, I, a[1000010];int L;vector &lt;int&gt; v;int pans = 0, fans = 0;int main()&#123; ios::sync_with_stdio(false); cin &gt;&gt; n &gt;&gt; I; for (int i = 1; i &lt;= n; i ++) cin &gt;&gt; a[i]; (I *= 8) /= n; if (I &gt; 30) &#123; cout &lt;&lt; 0 &lt;&lt; endl; return 0; &#125; L = (1 &lt;&lt; I); int mx = 0; sort(a + 1, a + n + 1); for (int i = 1; i &lt;= n; i ++) &#123; int j = i; while (j + 1 &lt;= n &amp;&amp; a[j + 1] == a[i]) j ++; int num = j - i + 1; v.push_back(num); pans += num; if (v.size() &gt; L) pans -= v[v.size() - 1 - L]; // cerr &lt;&lt; num &lt;&lt; " " &lt;&lt; pans &lt;&lt; endl; fans = max (fans, pans); i = j; &#125; cout &lt;&lt; n - fans &lt;&lt; endl; return 0;&#125; B. Welfare StateStatement: Given a array of n integers, support two operations: 1) modify one value. 2) input v, apply a_i = max (a_i, v) to every i. Output the value of every integers in the end. Tutorial: In the contest, I coded a SegTree with lazy mark within 10 minutes, achieving $O(nlogn)$ time. However, noticing that only one Option 2 will be useful and Option 1&amp;2 wouldn’t influence each other, we can calculate options independentely and combine them in the end. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cmath&gt;#include &lt;cstring&gt;#include &lt;ctime&gt;#include &lt;vector&gt;using namespace std;typedef long long ll;int n, q;int ins[200020];typedef struct node &#123; int st, ed; node *l, *r; int lz, v; node (int stt, int edd, int lzz, int vv, node *L, node *R) &#123; st = stt, ed = edd, lz = -1, v = vv, l = L, r = R; &#125;&#125; *pnode;pnode build (int st, int ed) &#123; if (st == ed) &#123; pnode ne = new node (st, ed, 0, ins[st], 0, 0); return ne; &#125; int mid = (st + ed) &gt;&gt; 1; pnode ne = new node (st, ed, 0, 0, build (st, mid), build (mid + 1, ed)); return ne;&#125;void down (pnode r) &#123; if (!r || !r-&gt;l) return ; if (r-&gt;lz != -1) &#123; r-&gt;l-&gt;lz = max (r-&gt;l-&gt;lz, r-&gt;lz); r-&gt;r-&gt;lz = max (r-&gt;r-&gt;lz, r-&gt;lz); r-&gt;l-&gt;v = max (r-&gt;l-&gt;v, r-&gt;lz); r-&gt;r-&gt;v = max (r-&gt;r-&gt;v, r-&gt;lz); r-&gt;lz = -1; &#125;&#125;void cover (pnode r, int st, int ed, int v) &#123; if (st &lt;= r-&gt;st &amp;&amp; r-&gt;ed &lt;= ed) &#123; r-&gt;lz = max (r-&gt;lz, v); r-&gt;v = max (r-&gt;v, v); return ; &#125; down (r); if (st &lt;= r-&gt;l-&gt;ed) cover (r-&gt;l, st, ed, v); if (r-&gt;r-&gt;st &lt;= ed) cover (r-&gt;r, st, ed, v); return ;&#125;void modify (pnode r, int p, int v) &#123; if (r-&gt;st == r-&gt;ed) &#123; r-&gt;v = v; return ; &#125; down (r); if (p &lt;= r-&gt;l-&gt;ed) modify(r-&gt;l, p, v); if (r-&gt;r-&gt;st &lt;= p) modify(r-&gt;r, p, v); return ;&#125;void order (pnode r) &#123; if (r-&gt;st == r-&gt;ed) &#123; cout &lt;&lt; r-&gt;v &lt;&lt; " "; return ; &#125; down (r); order(r-&gt;l); order(r-&gt;r);&#125;int main()&#123; ios::sync_with_stdio(false); cin &gt;&gt; n; for (int i = 1; i &lt;= n; i ++) cin &gt;&gt; ins[i]; pnode root = build (1, n); cin &gt;&gt; q; for (int i = 1; i &lt;= q; i ++) &#123; int tp, a, b; cin &gt;&gt; tp; if (tp == 1) &#123; cin &gt;&gt; a &gt;&gt; b; modify(root, a, b); &#125; if (tp == 2) &#123; cin &gt;&gt; a; cover (root, 1, n, a); &#125; &#125; order(root); cout &lt;&lt; endl; return 0;&#125; C. Matching vs Independent SetStatement: Given a graph with 3*n vertices and m edges, find either a matching of n edges, or an independent set of n vertices. Tutorial: Calculating the Maximum Independent Set and the Maximum Matching of a graph both have high time complexity, so we need to think about the unique feature of this task. 3*n vertices are the strongest hint. We add edges to a matching greedily till no new edge can be added. Then, it’s easy to see we must achieved one of the conditions. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cmath&gt;#include &lt;cstring&gt;#include &lt;ctime&gt;#include &lt;vector&gt;using namespace std;typedef long long ll;int n, m;struct e &#123;int to, next;&#125; edge[5000050];int point[3000030], te = 0;void add (int u, int v) &#123; te ++; edge[te].to = v; edge[te].next = point[u]; point[u] = te;&#125;int flag[3000030];vector &lt;int&gt; rec;int cnt = 0;int main()&#123; ios::sync_with_stdio(false); int T; cin &gt;&gt; T; while (T --) &#123; te = 1; cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= 3 * n; i ++) point[i] = flag[i] = 0; for (int a, b, i = 1; i &lt;= m; i ++) &#123; cin &gt;&gt; a &gt;&gt; b; add (a, b);add (b, a); &#125; rec.resize(0); cnt = 0; for (int i = 1; i &lt;= 3 * n; i ++) &#123; if (flag[i]) continue ; for (int e = point[i]; e; e = edge[e].next) &#123; int to = edge[e].to; if (!flag[to]) &#123; flag[to] = flag[i] = 1; rec.push_back(e / 2); cnt ++; break; &#125; &#125; &#125; if (cnt &gt;= n) &#123; cout &lt;&lt; "Matching" &lt;&lt; '\n'; for (int i = 0; i &lt; n; i ++) cout &lt;&lt; rec[i] &lt;&lt; " "; cout &lt;&lt; '\n'; &#125; else &#123; int ans = 0; cout &lt;&lt; "IndSet" &lt;&lt; '\n'; for (int i = 1; i &lt;= 3 * n &amp;&amp; ans &lt; n; i ++) if (!flag[i]) &#123; cout &lt;&lt; i &lt;&lt; ' '; ans ++; &#125; cout &lt;&lt; '\n'; &#125; &#125; return 0;&#125; D. Rectangle Painting 1Statement: A square grid of size nn ($n \leq 50$) has some cells colored in black. Colored a rectangle of size h w into white requires $max(h, w)$ costs. Calculate the miminum cost to whiten the whole grid. Tutorial: The necessary condition of costing less than n is to leave one column uncovered. This feature suggests us to use DP on rectangles, with $O(n^4)$ states and $O(n)$ time to calculate one state, enumerating the missing column. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;#include &lt;ctime&gt;#include &lt;queue&gt;#include &lt;vector&gt;#include &lt;set&gt;#define TIME (double)clock()/CLOCKS_PER_SECusing namespace std;typedef long long ll;int n;int mp[55][55];int sum[55][55], s[2][55][55];int rec[55][55][55][55];int dfs (int stx, int sty, int edx, int edy) &#123; if (edx &lt; stx || edy &lt; sty) return 0; if (~rec[stx][sty][edx][edy]) return rec[stx][sty][edx][edy]; if (sum[edx][edy] - sum[stx - 1][edy] - sum[edx][sty - 1] + sum[stx - 1][sty - 1] == 0) &#123; rec[stx][sty][edx][edy] = 0; return 0; &#125; rec[stx][sty][edx][edy] = max (edx - stx + 1, edy - sty + 1); for (int x = stx; x &lt;= edx; x ++) &#123; if (s[0][x][edy] - s[0][x][sty - 1] != 0) continue ; rec[stx][sty][edx][edy] = min (rec[stx][sty][edx][edy], dfs (stx, sty, x - 1, edy) + dfs (x + 1, sty, edx, edy)); if (dfs (stx, sty, x - 1, edy) &gt;= rec[stx][sty][edx][edy]) break; &#125; for (int y = sty; y &lt;= edy; y ++) &#123; if (s[1][edx][y] - s[1][stx - 1][y] != 0) continue ; rec[stx][sty][edx][edy] = min (rec[stx][sty][edx][edy], dfs (stx, sty, edx, y - 1) + dfs (stx, y + 1, edx, edy)); if (dfs (stx, sty, edx, y - 1) &gt;= rec[stx][sty][edx][edy]) break; &#125; return rec[stx][sty][edx][edy];&#125;int main() &#123; cin &gt;&gt; n; for (int i = 1; i &lt;= n; i ++) for (int j = 1; j &lt;= n; j ++) &#123; char c; cin &gt;&gt; c; mp[i][j] = (c == '#' ? 1 : 0); sum[i][j] = mp[i][j] + sum[i][j - 1] + sum[i - 1][j] - sum[i - 1][j - 1]; s[0][i][j] = s[0][i][j - 1] + mp[i][j]; s[1][i][j] = s[1][i - 1][j] + mp[i][j]; &#125; memset(rec, -1, sizeof rec); cout &lt;&lt; dfs (1, 1, n, n) &lt;&lt; endl; // cerr &lt;&lt; TIME &lt;&lt; endl; return 0;&#125; E. Rectangle Painting 2Statement: A square grid of size nn ($n \leq 10^9$) has some cells colored in black， which are the union of m ($m \leq 50$) rectangles. Colored a rectangle of size h w into white requires $min(h, w)$ costs. Calculate the miminum cost to whiten the whole grid. Tutorial: Couldn’t find an easier Flow problem… The unwritten feature of this problem is that we are actually choosing columns and rows. As we construct a bipartite graph, we want to find the minimal vertex cover, which equals to the Maximum Flow. The only thing left is to compress identical vertices, to discretize the grid. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129//st: 11:55#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstdio&gt;#include &lt;cmath&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;ctime&gt;#include &lt;queue&gt;#include &lt;vector&gt;using namespace std;typedef pair &lt;int, int&gt; pii;#define F first#define S second#define MP make_pairint n, m;int ins[55][2][2];vector &lt;int&gt; c, r;namespace Flow &#123; const int oo = 2e9 + 10; int N = 0; int first[1010], point[1010], te = 1; struct e &#123;int to, next, flow;&#125; edge[1000010]; void add (int a, int b, int c) &#123; te ++; edge[te].to = b; edge[te].next = point[a]; edge[te].flow = c; point[a] = te; &#125; int dis[1010]; queue &lt;int&gt; q; bool bfs () &#123; for (int i = 0; i &lt;= N; i ++) dis[i] = oo; dis[0] = 0; q.push(0); while (!q.empty()) &#123; int x = q.front(); q.pop(); for (int e = point[x]; e; e = edge[e].next) &#123; int to = edge[e].to; if (edge[e].flow &amp;&amp; dis[to] == oo) &#123; dis[to] = dis[x] + 1; q.push(to); &#125; &#125; &#125; return (dis[N] != oo); &#125; int dfs (int x, int mx) &#123; if (x == N || mx == 0) return mx; int pans = 0; for (int &amp;e = first[x]; e; e = edge[e].next) &#123; int to = edge[e].to; if (edge[e].flow &amp;&amp; 1 + dis[x] == dis[to]) &#123; int flow = dfs (to, min(mx, edge[e].flow)); if (flow) &#123; pans += flow; mx -= flow; edge[e ^ 1].flow += flow; edge[e].flow -= flow; if (!mx) return pans; &#125; &#125; &#125; return pans; &#125; int fans = 0; void Dinic() &#123; while (bfs()) &#123; for (int i = 0; i &lt;= N; i ++) first[i] = point[i]; fans += dfs (0, oo); &#125; &#125; void main(vector &lt;int&gt; L, vector &lt;int&gt; R, vector &lt;pii&gt; E) &#123; N = L.size() + R.size() + 1; for (int i = 0; i &lt; L.size(); i ++) &#123; add (0, i + 1, L[i]); add (i + 1, 0, 0); &#125; for (int i = 0; i &lt; R.size(); i ++) &#123; add (L.size() + i + 1, N, R[i]); add (N, L.size() + i + 1, 0); &#125; for (int i = 0; i &lt; E.size(); i ++) &#123; add (E[i].F + 1, E[i].S + L.size() + 1, oo); add (E[i].S + L.size() + 1, E[i].F + 1, 0); &#125; Dinic(); cout &lt;&lt; fans &lt;&lt; endl; &#125;&#125;int main() &#123; ios::sync_with_stdio(false); vector &lt;int&gt; left, right; vector &lt;pii&gt; edge; cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= m; i ++) &#123; int x1, y1, x2, y2; cin &gt;&gt; x1 &gt;&gt; y1 &gt;&gt; x2 &gt;&gt; y2; c.push_back(x1); c.push_back(x2 + 1); r.push_back(y1); r.push_back(y2 + 1); ins[i][0][0] = x1, ins[i][0][1] = y1; ins[i][1][0] = x2, ins[i][1][1] = y2; &#125; c.push_back(n + 1); r.push_back(n + 1); sort(c.begin(), c.end()); sort(r.begin(), r.end()); for (int i = 0; i &lt; c.size() - 1; i ++) left.push_back(c[i + 1] - c[i]); for (int i = 0; i &lt; r.size() - 1; i ++) right.push_back(r[i + 1] - r[i]); for (int i = 0; i &lt; c.size() - 1; i ++) for (int j = 0; j &lt; r.size() - 1; j ++) for (int k = 1; k &lt;= m; k ++) if (ins[k][0][0] &lt;= c[i] &amp;&amp; c[i + 1] - 1 &lt;= ins[k][1][0] &amp;&amp; ins[k][0][1] &lt;= r[j] &amp;&amp; r[j + 1] - 1 &lt;= ins[k][1][1]) edge.push_back(MP(i, j)); Flow::main(left, right, edge); return 0;&#125; F. GCD Groups 2Statement: Given an array of n ($2 \leq n \leq 10^5$) integers, splite them into two groups so that the GCDs of both groups equal to one. Tutorial: The vital feature to open this problem is that each number has no more than k=9 divisors. If the answer is YES, every number could be put into a group with size no more than 9, because at most 9 numbers are vital to keep GCD down to 1. First, we randomly selected two numbers and assert them to be in different groups. The failing possibility of this step is negligible. Then, it’s easy to construct a subset DP with $O(n*2^{2k})$ complexity. Only $2^{2k}$ states are important to reduce the GCD down to 1. Observing closer, we find that we only need no more than 2*k candidates for each prime. Therefore, we pre-calculated the relationship between n numbers and k primes, and reduced the complexity of DP to $O(nk + k^22^{2k})$. The code below is randomization + greedy. Don’t ask my why…It’s neat. :D The idea of only choosing useful elements, as implemented below, is also non-trivial. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;#include &lt;ctime&gt;#include &lt;queue&gt;#include &lt;vector&gt;#include &lt;set&gt;#define F first#define S second#define MP make_pair#define TIME (double)clock()/CLOCKS_PER_SECusing namespace std;int gcd (int a, int b) &#123;if (!a||!b)return a+b; return gcd (b, a % b);&#125;int n;pair &lt;int, int&gt; a[1000010];int bel[1000010];bool fail() &#123; int g = 0; for (int i = 1; i &lt;= n; i ++) g = gcd (g, a[i].F); return (g != 1);&#125;int main() &#123; ios::sync_with_stdio(false); cin &gt;&gt; n; for (int v, i = 1; i &lt;= n; i ++) cin &gt;&gt; v, a[i] = MP(v, i); if (fail()) &#123; cout &lt;&lt; "NO" &lt;&lt; endl; return 0; &#125; int CNT = 0; while (true) &#123; if (((++CNT)&amp;127)==0 &amp;&amp; TIME &gt; 0.45)&#123; cout &lt;&lt; "NO" &lt;&lt; endl; // cerr &lt;&lt; "loop TIME: " &lt;&lt; CNT &lt;&lt; endl; return 0; &#125; random_shuffle(a + 1, a + n + 1); int g1 = 0, g2 = 0; for (int i = 1; i &lt;= n; i ++) &#123; int pre = gcd (g1, a[i].F); if (pre != g1) g1 = pre, bel[a[i].S] = 1; else g2 = gcd (g2, a[i].F), bel[a[i].S] = 2; &#125; if (g1 == 1 &amp;&amp; g2 == 1) &#123; cout &lt;&lt; "YES" &lt;&lt; endl; for (int i = 1; i &lt;= n; i ++) cout &lt;&lt; bel[i] &lt;&lt; ' '; cout &lt;&lt; endl; return 0; &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>Competitions</category>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>CS</tag>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Markdown使用攻略]]></title>
    <url>%2F2019-07-28-Markdown%E4%BD%BF%E7%94%A8%E6%94%BB%E7%95%A5.html</url>
    <content type="text"><![CDATA[前置技能：Markdown一、Markdown 是什么Markdown 是一种标记语言。在写作时，你的所有文字都是没有样式的纯文本，在其中插入若干 Markdown 标记后，被标记的文字便有了样式。样式将会在渲染的时候呈现，并且样式的显示效果由 Markdown 工具决定。 比如，在你所写的文字中，你希望某一行的最终排版呈现一级标题的样式，那就给这行文字加个一级标题的标记；某个地方有两个字需要加粗，那就给这两个字加个粗体标记，最终的排版效果中这两字就会是粗体模样。 二、Markdown 的使用方法前面说了，Markdown 其实就是给文章内容作标记，把某处内容标记成什么那它最终就呈现对应的样式，而这些标记是一些简单的符号。 那 Markdown 标记都有哪些，样式效果是怎么的呢？ 常用的标记 1. 二级标题1## 这是二级标题 2. 三级标题1### 这是三级标题 3. 四级标题1#### 这是四级标题 4. 粗体1这是**粗体** 5. 引用1&gt; 这是引用 6. 有序列表1234Markdown 中列表有两种：1. 有序列表，像这样带序号的。其写法是：每项的序号以数字、点、空格组成2. 无序列表，不带序号的，也就是后面那种 7. 无序列表123456无序列表有两种相同效果的写法：* 用 * 和一个空格开头- 用 - 和一个空格开头一个列表中我们应该始终用同一种写法，不用混用 * 和 - 8. 链接1[这是链接文本](https://xx.xx/xx) 9. 插入图片1![任意图片名称](https://picture-gallery.oss-cn-shanghai.aliyuncs.com/markdown/markdown_logo.png) 10. 插入表格1234| 表头1 | 表头2 || --- | --- || 单元格1 | 单元格2 || 单元格3 | 单元格4 | 不常用但可能会用到的标记 1. 代码块1234```pythonprint(&apos;代码块表示多行代码，使用```来开头和结尾代码块&apos;)print(&apos;语言标识可选，若有则可自动高亮代码元素&apos;)``` 2. 行内代码1这是行内代码 `echo 行内代码嵌入在某一行文本中 3. 一级标题1# 这是一级标题 4. 五级标题1##### 这是五级标题 5. 六级标题1###### 这是六级标题 6. 分割线1--- 7. 斜体1这是*斜体* 8. 删除线1这是~~删除线~~ 三、图床之前介绍了 Markdown 插入图片的方式： 1![任意图片名称](https://xx.xx/xx) 这里演示的链接是网络链接，其实也可以使用本地图片的的文件路径，形式如下： 1![任意图片名称](C:\Documents\sample.png) 四、Markdown 标记的典型使用标题 文章的顶层标题使用二级标题 每个小节的标题使用三级标题 小节中进一步分层组织时使用四级标题 尽量少用五级标题和六级标题，考虑用有序列表和无序列表代替 完全不用一级标题 粗体、斜体需要强调某处内容时使用粗体。在中文排版中不使用斜体。在英文排版中可用斜体表达强调，或表示书名、题目。 引用以下情况使用引用标记： 引述内容时（也可直接用引号替代） 作示例时 给出提示、警告等额外说明时 行内代码、代码块1`echo 'Hello World' 图片Markdown 中使用1![图片名称](https://xx.xx/xx) 来插入图片，这里的「图片名称」可以任取，但是推荐使用对图片主题具有描述性的文字。因为在一些网站或软件中，图片无法加载时会显示这个「图片名称」，这时至少还能给读者传递出一点有用信息。 六、结语前面总共介绍了 18 种 Markdown 标记，其实常用的也就 10 种左右，这些标记符号都很简单，不出二十分钟便能全部记住。以后在写作的时候请尽量去使用 Markdown，一方面反复的练习会使你牢牢记住各种标记符号，使用时信手拈来；另一方面，Markdown 的使用会大大方便你写作，减少排版带来的负担。请坚信 Markdown 会为你带来生产力的提升。 学习自知乎，代码之外的自我修养专栏，作者黄浮云]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>CS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[function testing]]></title>
    <url>%2F2019-07-27-function-testing.html</url>
    <content type="text"><![CDATA[123456789101112131415#include &lt;ctime&gt;#include &lt;cmath&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;int main() &#123; ios::sync_with_stdio(false); string s; s = "Hello World！"; cout &lt;&lt; s &lt;&lt; endl; return 0;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019-07-26-MyFirstBlog.html</url>
    <content type="text"><![CDATA[Simulated-Anneal, this is your new start.]]></content>
  </entry>
</search>
