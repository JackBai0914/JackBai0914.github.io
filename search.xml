<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[宾夕法尼亚大学 访校印象]]></title>
    <url>%2F2019-08-27-UPenn.html</url>
    <content type="text"><![CDATA[〇.基本信息学校名称：宾夕法尼亚大学 英文：University of Pennsylvania 位置: Philadelphia, PA 19104 排名：综合性大学排名第8（2018 US News） 性质：综合性大学 在校生人数：21，826 录取率：9.3% （2017） 国际生比例：6.6% 学费（不含食宿）：45，556 课堂大小：83%的课堂少于30人 要求住宿的年级：大一 离学校最近的机场：Philadelphia International Airport (PHL) SAT：阅读 680-750；数学 690-770（2017） ACT：32-35（2017） 托福：100 （最低要求80） 一.校园环境宾大的校园不大不小，主要建筑之间的距离不远。建筑的主要色调是红色，风格比较古老。我们沿着Locust Walk一路走，环境很好，各个建筑就散布在周围。 我们先到了学校的图书馆Van pelt。里面学生不多，但是看起来都在安静，认真地学习。学生用的电脑设备很好，我看到了一个学生在用带弧形的双屏读论文写报告。从图书馆出来，我们能看见著名的纽扣和富兰克林的雕塑。 走到Locust Walk的尽头就来到了Warton商学院的位置。这栋建筑从外面看不显眼，但这是宾大的核心，是排名第一的商学院。我们正好赶上了2020届新生的入学仪式，发现Warton的各个Cohert竟然都是以货币单位命名的… 二.学术能力：寻问招生官从宾大以后的学校，我都有机会参加AO的information session或者现场找AO问问题。我第一次主动找招生官，表现的还是比较局促。之后要多问一些问题，对每个问题都有一些跟进，尤其是在自己喜欢的学校。 我首先询问了关于计算机专业的问题：是否有CS相关的非CS专业？AO告诉我是没有的。然后他给我仔细介绍了学生如何选择多个自己喜欢的专业：1/3的宾大学生都会选择major + minor的形式。而对于计算机，大部分人都会放在minor的位置，作为自己研究其他专业的一个工具。major的课程需要完成core的30门课程，而minor的课程只有十几门必修课。 进一步地，CS的专业在文理学院和工程院都有开设。一般人minor的都会是文理学院的那一个，它可能深度较浅但是较广。如果major工程院的CS专业，AO说，那很少有人会再minor其他的专业，因为工程院对CS对major的要求会比较高。 三.申请相关我也询问了招生官关于申请的问题。 123Q: 申请中什么最重要？A: AO传递的最主要的信息是，out-of-classroom与学术能力一样重要；Show us who you are是申请最主要的目标。 123Q: 活动列表应该怎样安排？A: 写对我影响最大，最重要的活动。当然，我也应该考虑到，这些活动group together以后会给招生官展现怎样的自己。最后，多余的活动也可以作为补充信息，做成resume交上去。 四.额外信息12345678910111213141516171819202122Q：能评价下费城是个怎样的城市吗？Lynn：文化氛围比较浓厚，城市中心有很地标性的建筑。虽然建筑风格比较老，玩乐也不像纽约那么丰富，但是该有的娱乐设施都有，能找到好吃的餐馆和KTV。整个城市的设计感觉会和国内比较像：比较紧凑不需要车，不过活动半径并不是特别大。Q：那学校的人文环境怎么样？Ni Ruoyang：因为是一个职业型（Pre-professional）大学，大家都想去沃顿，所以几乎没有人文环境。很多社团的运作都很商业化。刘奕麟：在宾大很容易会把自己禁锢在商业生活中。其实校园还是很多元的，想找肯定能找到人文氛围，也有学生互相辩论聊天地、聊政治的社团。Q：学校的强势学科有哪些？刘奕麟：沃顿有很多业界中最好的教授，所有人都争取在大四毕业前抢到最好的教授，管理的老师。文理院里面，宾大的经济和政治学挺强的。Q：学校除了商科以外，还有什么别的强势科目吗？只有商科好是一个误区吗？Lynn：宾大肯定是以商业为主。不可否认的是，我们学校的文理学院还是比较强的，文学和艺术史也比较强。在学校进来之后能申请双学位（Dual Degree），很多非商科的人也会选择商科作为第二学位。大一入学前就要申请的双学位项目有M&amp;T，Huntsman。这种双学位项目出来发展也很好的。Q：学校的必修课和选修课有哪些？刘奕麟：学校的体育课程不算分。要求的话和别的大学类似，分通识课和专业课。毕业要完成通识课，7个不同科目型的要求（Sectors），还有专业课及自由选修课。Q：平时课业压力大吗？Ni Ruoyang：在沃顿，课业并不会过于繁重，会根据大家的表现给分（Grade on a Curve）。沃顿的压力可能不在他们的课业难度上，课堂上会有很多以小组为单位进行的案例研究。这样的实战案例通常会占用很大的时间。刘奕麟：文理院的课业压力还是蛮大的。学校的数学教学比较差。因为注重研究，所以教学质量不一定好，很多老师不会怎么教学生。不过总体来说，你的时间付出和你收获的知识是成正比的。作者：Panopath过来人链接：https://www.zhihu.com/question/24297668/answer/350786305]]></content>
      <categories>
        <category>College Application</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[哥伦比亚大学访校记录]]></title>
    <url>%2F2019-08-25-Columbia-University.html</url>
    <content type="text"><![CDATA[一.总结感觉上，哥大是一个精致，古典与现代结合的学校。地理位置优越，生活便利；工科教授的水平一流，学生水平，工程资源一般；需要主动利用资源。 总体感觉挺好的。也有朋友和父母熟人在旁边。只是在最繁华的市中心度过4年，不知道是否能保持学术的初心？ 二.校园环境学校坐落在纽约市中心，曼哈顿岛的中部，大约在110-120街区。中心是一个图书馆和一个大草坪，还有一个圆顶式建筑。吉祥物是狮子，不过实在有点瘦… 学校占地面积小。不过教学楼不仅在“校区”里，而是和城市融合。工学院的楼(Science Building)比较新。 据学长说，吃饭的地方很多，中餐很好。生活很方便，“开学背个电脑去就完事儿了”。 工学院的楼下有独立的咖啡厅。走过的时候，看见两个学生安静的一起坐在那里指尖飞舞。一杯咖啡，一个并肩探索的同学，在这里待一整天，也挺让人安心的。 三.学术能力按学长的话说，CS专业的学生普遍不是很厉害(厉害的都去MIT&amp;Stanford&amp;Princeton了)，但是教授很厉害(包括几个图灵奖+算法导论的作者)。可以跳课，可以修研究生课程；可以上上数学系的课，因为哥大纯数也挺好。 学长指出哥大的CS偏向理论。这其实挺好(比宾大好多了)，毕竟精通理论是之后做事情的必要条件。 哥大的人文Core对于工程院的学生选修，但是大部分同学还是会选一些。包括一些很好的通识课程，能让我浅层次地了解一些历史，哲学的知识。]]></content>
      <categories>
        <category>College Application</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[一道划痕]]></title>
    <url>%2F2019-08-08-%E5%8F%8D%E6%80%9D.html</url>
    <content type="text"><![CDATA[现在的状态，不能支撑你到达彼岸。 你变成了一个爱偷懒的人。之前跑的太累了是你的借口，于是现在就“暂时性”的放松。你不知道申请是你的最后一搏吗？没有了锐气，斗志和状态，你什么都不是。你是很努力的奔跑过。可是这不代表你现在就有休息的权利。冲刺的时候休息。你会发现那些弱智的同学也能超过你。这不可怕吗？ 你像以前一样无视规矩。可是，你难道分不清哪些是为自己好吗？你欠下DDL真的不羞愧吗？一次次的保证，真的不觉得以后会后悔？你连计划，都不会定了。你这样下去，完蛋了。 还能记起来斯坦福的梦吗？ 热闹的小宿舍，简朴的小房间；像海绵一样的作业，不Carry不爽课堂；做宿舍里第一个起床的人，静听着开水的滚沸和隔壁传来的琴声；清晨6点钟的阳光，Dry Lake旁的落日；性情随和，却对数学嗅觉敏锐的华裔同学，还有，笑容带着酒窝的那个女生…… 这些回忆，我已许久未曾想起。它们闪光的表面也蒙上了灰尘。这也很正常吧？斯坦福啊，对它感兴趣的同学还不够多吗？我是自作多情了，参加了个夏校，就以为发生了什么不得了的事，造就了我们的缘分。可事实是，痴迷斯坦福的人成千上万；99%的人做后都是抱着痛心离开，片面的讲成为失败者。我呢，大不了就是他们之一。 可是，我为什么又觉得自己不平常呢？每个人都能看到加州六点的晨雾吗？每个人都能在那些红色的房子里，做着assignments兴奋得发抖吗？每个人都会在营里认识几个忘不了的朋友吗？ 真是可笑。剥去执念，我竟真的找不到自己追求的方向了。以后会后悔的。我可不想知道这是一种什么样的感觉，失败者。 从糊涂的梦里醒过来吧。你还有机会，走向光明。]]></content>
      <categories>
        <category>其他</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[[Codeforces]CR576 比赛记录]]></title>
    <url>%2F2019-08-03-Codeforces-CR576.html</url>
    <content type="text"><![CDATA[Codeforces Round #576 (Div. 1)1. General Info Problem: ABCD solved, EF unread. Ranking: 167 out of 662. Rating: 2179 -&gt; 2221 (+42). Summary: Mistakenly understood A at first, and wasted two submissions. Solved C, a constructive task based on Independent Set and Node Matching. Wasted too much time on D, a brute force with a trivial feature. 2. ProblemsA. MP3Statement: Given n intergers, calculate the maximum numbers of integers we can get by choosing m consecutive values inputed. Tutorial: In the contest, I used Two Pointers to go through the sorted sequence. Yet, we can transformed the array into value-indexed form and calculated the prefix. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cmath&gt;#include &lt;cstring&gt;#include &lt;ctime&gt;#include &lt;vector&gt;using namespace std;typedef long long ll;int n, I, a[1000010];int L;vector &lt;int&gt; v;int pans = 0, fans = 0;int main()&#123; ios::sync_with_stdio(false); cin &gt;&gt; n &gt;&gt; I; for (int i = 1; i &lt;= n; i ++) cin &gt;&gt; a[i]; (I *= 8) /= n; if (I &gt; 30) &#123; cout &lt;&lt; 0 &lt;&lt; endl; return 0; &#125; L = (1 &lt;&lt; I); int mx = 0; sort(a + 1, a + n + 1); for (int i = 1; i &lt;= n; i ++) &#123; int j = i; while (j + 1 &lt;= n &amp;&amp; a[j + 1] == a[i]) j ++; int num = j - i + 1; v.push_back(num); pans += num; if (v.size() &gt; L) pans -= v[v.size() - 1 - L]; // cerr &lt;&lt; num &lt;&lt; " " &lt;&lt; pans &lt;&lt; endl; fans = max (fans, pans); i = j; &#125; cout &lt;&lt; n - fans &lt;&lt; endl; return 0;&#125; B. Welfare StateStatement: Given a array of n integers, support two operations: 1) modify one value. 2) input v, apply a_i = max (a_i, v) to every i. Output the value of every integers in the end. Tutorial: In the contest, I coded a SegTree with lazy mark within 10 minutes, achieving $O(nlogn)$ time. However, noticing that only one Option 2 will be useful and Option 1&amp;2 wouldn’t influence each other, we can calculate options independentely and combine them in the end. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cmath&gt;#include &lt;cstring&gt;#include &lt;ctime&gt;#include &lt;vector&gt;using namespace std;typedef long long ll;int n, q;int ins[200020];typedef struct node &#123; int st, ed; node *l, *r; int lz, v; node (int stt, int edd, int lzz, int vv, node *L, node *R) &#123; st = stt, ed = edd, lz = -1, v = vv, l = L, r = R; &#125;&#125; *pnode;pnode build (int st, int ed) &#123; if (st == ed) &#123; pnode ne = new node (st, ed, 0, ins[st], 0, 0); return ne; &#125; int mid = (st + ed) &gt;&gt; 1; pnode ne = new node (st, ed, 0, 0, build (st, mid), build (mid + 1, ed)); return ne;&#125;void down (pnode r) &#123; if (!r || !r-&gt;l) return ; if (r-&gt;lz != -1) &#123; r-&gt;l-&gt;lz = max (r-&gt;l-&gt;lz, r-&gt;lz); r-&gt;r-&gt;lz = max (r-&gt;r-&gt;lz, r-&gt;lz); r-&gt;l-&gt;v = max (r-&gt;l-&gt;v, r-&gt;lz); r-&gt;r-&gt;v = max (r-&gt;r-&gt;v, r-&gt;lz); r-&gt;lz = -1; &#125;&#125;void cover (pnode r, int st, int ed, int v) &#123; if (st &lt;= r-&gt;st &amp;&amp; r-&gt;ed &lt;= ed) &#123; r-&gt;lz = max (r-&gt;lz, v); r-&gt;v = max (r-&gt;v, v); return ; &#125; down (r); if (st &lt;= r-&gt;l-&gt;ed) cover (r-&gt;l, st, ed, v); if (r-&gt;r-&gt;st &lt;= ed) cover (r-&gt;r, st, ed, v); return ;&#125;void modify (pnode r, int p, int v) &#123; if (r-&gt;st == r-&gt;ed) &#123; r-&gt;v = v; return ; &#125; down (r); if (p &lt;= r-&gt;l-&gt;ed) modify(r-&gt;l, p, v); if (r-&gt;r-&gt;st &lt;= p) modify(r-&gt;r, p, v); return ;&#125;void order (pnode r) &#123; if (r-&gt;st == r-&gt;ed) &#123; cout &lt;&lt; r-&gt;v &lt;&lt; " "; return ; &#125; down (r); order(r-&gt;l); order(r-&gt;r);&#125;int main()&#123; ios::sync_with_stdio(false); cin &gt;&gt; n; for (int i = 1; i &lt;= n; i ++) cin &gt;&gt; ins[i]; pnode root = build (1, n); cin &gt;&gt; q; for (int i = 1; i &lt;= q; i ++) &#123; int tp, a, b; cin &gt;&gt; tp; if (tp == 1) &#123; cin &gt;&gt; a &gt;&gt; b; modify(root, a, b); &#125; if (tp == 2) &#123; cin &gt;&gt; a; cover (root, 1, n, a); &#125; &#125; order(root); cout &lt;&lt; endl; return 0;&#125; C. Matching vs Independent SetStatement: Given a graph with 3*n vertices and m edges, find either a matching of n edges, or an independent set of n vertices. Tutorial: Calculating the Maximum Independent Set and the Maximum Matching of a graph both have high time complexity, so we need to think about the unique feature of this task. 3*n vertices are the strongest hint. We add edges to a matching greedily till no new edge can be added. Then, it’s easy to see we must achieved one of the conditions. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cmath&gt;#include &lt;cstring&gt;#include &lt;ctime&gt;#include &lt;vector&gt;using namespace std;typedef long long ll;int n, m;struct e &#123;int to, next;&#125; edge[5000050];int point[3000030], te = 0;void add (int u, int v) &#123; te ++; edge[te].to = v; edge[te].next = point[u]; point[u] = te;&#125;int flag[3000030];vector &lt;int&gt; rec;int cnt = 0;int main()&#123; ios::sync_with_stdio(false); int T; cin &gt;&gt; T; while (T --) &#123; te = 1; cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= 3 * n; i ++) point[i] = flag[i] = 0; for (int a, b, i = 1; i &lt;= m; i ++) &#123; cin &gt;&gt; a &gt;&gt; b; add (a, b);add (b, a); &#125; rec.resize(0); cnt = 0; for (int i = 1; i &lt;= 3 * n; i ++) &#123; if (flag[i]) continue ; for (int e = point[i]; e; e = edge[e].next) &#123; int to = edge[e].to; if (!flag[to]) &#123; flag[to] = flag[i] = 1; rec.push_back(e / 2); cnt ++; break; &#125; &#125; &#125; if (cnt &gt;= n) &#123; cout &lt;&lt; "Matching" &lt;&lt; '\n'; for (int i = 0; i &lt; n; i ++) cout &lt;&lt; rec[i] &lt;&lt; " "; cout &lt;&lt; '\n'; &#125; else &#123; int ans = 0; cout &lt;&lt; "IndSet" &lt;&lt; '\n'; for (int i = 1; i &lt;= 3 * n &amp;&amp; ans &lt; n; i ++) if (!flag[i]) &#123; cout &lt;&lt; i &lt;&lt; ' '; ans ++; &#125; cout &lt;&lt; '\n'; &#125; &#125; return 0;&#125; D. Rectangle Painting 1Statement: A square grid of size nn ($n \leq 50$) has some cells colored in black. Colored a rectangle of size h w into white requires $max(h, w)$ costs. Calculate the miminum cost to whiten the whole grid. Tutorial: The necessary condition of costing less than n is to leave one column uncovered. This feature suggests us to use DP on rectangles, with $O(n^4)$ states and $O(n)$ time to calculate one state, enumerating the missing column. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;#include &lt;ctime&gt;#include &lt;queue&gt;#include &lt;vector&gt;#include &lt;set&gt;#define TIME (double)clock()/CLOCKS_PER_SECusing namespace std;typedef long long ll;int n;int mp[55][55];int sum[55][55], s[2][55][55];int rec[55][55][55][55];int dfs (int stx, int sty, int edx, int edy) &#123; if (edx &lt; stx || edy &lt; sty) return 0; if (~rec[stx][sty][edx][edy]) return rec[stx][sty][edx][edy]; if (sum[edx][edy] - sum[stx - 1][edy] - sum[edx][sty - 1] + sum[stx - 1][sty - 1] == 0) &#123; rec[stx][sty][edx][edy] = 0; return 0; &#125; rec[stx][sty][edx][edy] = max (edx - stx + 1, edy - sty + 1); for (int x = stx; x &lt;= edx; x ++) &#123; if (s[0][x][edy] - s[0][x][sty - 1] != 0) continue ; rec[stx][sty][edx][edy] = min (rec[stx][sty][edx][edy], dfs (stx, sty, x - 1, edy) + dfs (x + 1, sty, edx, edy)); if (dfs (stx, sty, x - 1, edy) &gt;= rec[stx][sty][edx][edy]) break; &#125; for (int y = sty; y &lt;= edy; y ++) &#123; if (s[1][edx][y] - s[1][stx - 1][y] != 0) continue ; rec[stx][sty][edx][edy] = min (rec[stx][sty][edx][edy], dfs (stx, sty, edx, y - 1) + dfs (stx, y + 1, edx, edy)); if (dfs (stx, sty, edx, y - 1) &gt;= rec[stx][sty][edx][edy]) break; &#125; return rec[stx][sty][edx][edy];&#125;int main() &#123; cin &gt;&gt; n; for (int i = 1; i &lt;= n; i ++) for (int j = 1; j &lt;= n; j ++) &#123; char c; cin &gt;&gt; c; mp[i][j] = (c == '#' ? 1 : 0); sum[i][j] = mp[i][j] + sum[i][j - 1] + sum[i - 1][j] - sum[i - 1][j - 1]; s[0][i][j] = s[0][i][j - 1] + mp[i][j]; s[1][i][j] = s[1][i - 1][j] + mp[i][j]; &#125; memset(rec, -1, sizeof rec); cout &lt;&lt; dfs (1, 1, n, n) &lt;&lt; endl; // cerr &lt;&lt; TIME &lt;&lt; endl; return 0;&#125; E. Rectangle Painting 2Statement: A square grid of size nn ($n \leq 10^9$) has some cells colored in black， which are the union of m ($m \leq 50$) rectangles. Colored a rectangle of size h w into white requires $min(h, w)$ costs. Calculate the miminum cost to whiten the whole grid. Tutorial: Couldn’t find an easier Flow problem… The unwritten feature of this problem is that we are actually choosing columns and rows. As we construct a bipartite graph, we want to find the minimal vertex cover, which equals to the Maximum Flow. The only thing left is to compress identical vertices, to discretize the grid. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129//st: 11:55#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstdio&gt;#include &lt;cmath&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;ctime&gt;#include &lt;queue&gt;#include &lt;vector&gt;using namespace std;typedef pair &lt;int, int&gt; pii;#define F first#define S second#define MP make_pairint n, m;int ins[55][2][2];vector &lt;int&gt; c, r;namespace Flow &#123; const int oo = 2e9 + 10; int N = 0; int first[1010], point[1010], te = 1; struct e &#123;int to, next, flow;&#125; edge[1000010]; void add (int a, int b, int c) &#123; te ++; edge[te].to = b; edge[te].next = point[a]; edge[te].flow = c; point[a] = te; &#125; int dis[1010]; queue &lt;int&gt; q; bool bfs () &#123; for (int i = 0; i &lt;= N; i ++) dis[i] = oo; dis[0] = 0; q.push(0); while (!q.empty()) &#123; int x = q.front(); q.pop(); for (int e = point[x]; e; e = edge[e].next) &#123; int to = edge[e].to; if (edge[e].flow &amp;&amp; dis[to] == oo) &#123; dis[to] = dis[x] + 1; q.push(to); &#125; &#125; &#125; return (dis[N] != oo); &#125; int dfs (int x, int mx) &#123; if (x == N || mx == 0) return mx; int pans = 0; for (int &amp;e = first[x]; e; e = edge[e].next) &#123; int to = edge[e].to; if (edge[e].flow &amp;&amp; 1 + dis[x] == dis[to]) &#123; int flow = dfs (to, min(mx, edge[e].flow)); if (flow) &#123; pans += flow; mx -= flow; edge[e ^ 1].flow += flow; edge[e].flow -= flow; if (!mx) return pans; &#125; &#125; &#125; return pans; &#125; int fans = 0; void Dinic() &#123; while (bfs()) &#123; for (int i = 0; i &lt;= N; i ++) first[i] = point[i]; fans += dfs (0, oo); &#125; &#125; void main(vector &lt;int&gt; L, vector &lt;int&gt; R, vector &lt;pii&gt; E) &#123; N = L.size() + R.size() + 1; for (int i = 0; i &lt; L.size(); i ++) &#123; add (0, i + 1, L[i]); add (i + 1, 0, 0); &#125; for (int i = 0; i &lt; R.size(); i ++) &#123; add (L.size() + i + 1, N, R[i]); add (N, L.size() + i + 1, 0); &#125; for (int i = 0; i &lt; E.size(); i ++) &#123; add (E[i].F + 1, E[i].S + L.size() + 1, oo); add (E[i].S + L.size() + 1, E[i].F + 1, 0); &#125; Dinic(); cout &lt;&lt; fans &lt;&lt; endl; &#125;&#125;int main() &#123; ios::sync_with_stdio(false); vector &lt;int&gt; left, right; vector &lt;pii&gt; edge; cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= m; i ++) &#123; int x1, y1, x2, y2; cin &gt;&gt; x1 &gt;&gt; y1 &gt;&gt; x2 &gt;&gt; y2; c.push_back(x1); c.push_back(x2 + 1); r.push_back(y1); r.push_back(y2 + 1); ins[i][0][0] = x1, ins[i][0][1] = y1; ins[i][1][0] = x2, ins[i][1][1] = y2; &#125; c.push_back(n + 1); r.push_back(n + 1); sort(c.begin(), c.end()); sort(r.begin(), r.end()); for (int i = 0; i &lt; c.size() - 1; i ++) left.push_back(c[i + 1] - c[i]); for (int i = 0; i &lt; r.size() - 1; i ++) right.push_back(r[i + 1] - r[i]); for (int i = 0; i &lt; c.size() - 1; i ++) for (int j = 0; j &lt; r.size() - 1; j ++) for (int k = 1; k &lt;= m; k ++) if (ins[k][0][0] &lt;= c[i] &amp;&amp; c[i + 1] - 1 &lt;= ins[k][1][0] &amp;&amp; ins[k][0][1] &lt;= r[j] &amp;&amp; r[j + 1] - 1 &lt;= ins[k][1][1]) edge.push_back(MP(i, j)); Flow::main(left, right, edge); return 0;&#125; F. GCD Groups 2Statement: Given an array of n ($2 \leq n \leq 10^5$) integers, splite them into two groups so that the GCDs of both groups equal to one. Tutorial: The vital feature to open this problem is that each number has no more than k=9 divisors. If the answer is YES, every number could be put into a group with size no more than 9, because at most 9 numbers are vital to keep GCD down to 1. First, we randomly selected two numbers and assert them to be in different groups. The failing possibility of this step is negligible. Then, it’s easy to construct a subset DP with $O(n*2^{2k})$ complexity. Only $2^{2k}$ states are important to reduce the GCD down to 1. Observing closer, we find that we only need no more than 2*k candidates for each prime. Therefore, we pre-calculated the relationship between n numbers and k primes, and reduced the complexity of DP to $O(nk + k^22^{2k})$. The code below is randomization + greedy. Don’t ask my why…It’s neat. :D The idea of only choosing useful elements, as implemented below, is also non-trivial. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;#include &lt;ctime&gt;#include &lt;queue&gt;#include &lt;vector&gt;#include &lt;set&gt;#define F first#define S second#define MP make_pair#define TIME (double)clock()/CLOCKS_PER_SECusing namespace std;int gcd (int a, int b) &#123;if (!a||!b)return a+b; return gcd (b, a % b);&#125;int n;pair &lt;int, int&gt; a[1000010];int bel[1000010];bool fail() &#123; int g = 0; for (int i = 1; i &lt;= n; i ++) g = gcd (g, a[i].F); return (g != 1);&#125;int main() &#123; ios::sync_with_stdio(false); cin &gt;&gt; n; for (int v, i = 1; i &lt;= n; i ++) cin &gt;&gt; v, a[i] = MP(v, i); if (fail()) &#123; cout &lt;&lt; "NO" &lt;&lt; endl; return 0; &#125; int CNT = 0; while (true) &#123; if (((++CNT)&amp;127)==0 &amp;&amp; TIME &gt; 0.45)&#123; cout &lt;&lt; "NO" &lt;&lt; endl; // cerr &lt;&lt; "loop TIME: " &lt;&lt; CNT &lt;&lt; endl; return 0; &#125; random_shuffle(a + 1, a + n + 1); int g1 = 0, g2 = 0; for (int i = 1; i &lt;= n; i ++) &#123; int pre = gcd (g1, a[i].F); if (pre != g1) g1 = pre, bel[a[i].S] = 1; else g2 = gcd (g2, a[i].F), bel[a[i].S] = 2; &#125; if (g1 == 1 &amp;&amp; g2 == 1) &#123; cout &lt;&lt; "YES" &lt;&lt; endl; for (int i = 1; i &lt;= n; i ++) cout &lt;&lt; bel[i] &lt;&lt; ' '; cout &lt;&lt; endl; return 0; &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>Competitions</category>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>CS</tag>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Markdown使用攻略]]></title>
    <url>%2F2019-07-28-Markdown%E4%BD%BF%E7%94%A8%E6%94%BB%E7%95%A5.html</url>
    <content type="text"><![CDATA[前置技能：Markdown一、Markdown 是什么Markdown 是一种标记语言。在写作时，你的所有文字都是没有样式的纯文本，在其中插入若干 Markdown 标记后，被标记的文字便有了样式。样式将会在渲染的时候呈现，并且样式的显示效果由 Markdown 工具决定。 比如，在你所写的文字中，你希望某一行的最终排版呈现一级标题的样式，那就给这行文字加个一级标题的标记；某个地方有两个字需要加粗，那就给这两个字加个粗体标记，最终的排版效果中这两字就会是粗体模样。 二、Markdown 的使用方法前面说了，Markdown 其实就是给文章内容作标记，把某处内容标记成什么那它最终就呈现对应的样式，而这些标记是一些简单的符号。 那 Markdown 标记都有哪些，样式效果是怎么的呢？ 常用的标记 1. 二级标题1## 这是二级标题 2. 三级标题1### 这是三级标题 3. 四级标题1#### 这是四级标题 4. 粗体1这是**粗体** 5. 引用1&gt; 这是引用 6. 有序列表1234Markdown 中列表有两种：1. 有序列表，像这样带序号的。其写法是：每项的序号以数字、点、空格组成2. 无序列表，不带序号的，也就是后面那种 7. 无序列表123456无序列表有两种相同效果的写法：* 用 * 和一个空格开头- 用 - 和一个空格开头一个列表中我们应该始终用同一种写法，不用混用 * 和 - 8. 链接1[这是链接文本](https://xx.xx/xx) 9. 插入图片1![任意图片名称](https://picture-gallery.oss-cn-shanghai.aliyuncs.com/markdown/markdown_logo.png) 10. 插入表格1234| 表头1 | 表头2 || --- | --- || 单元格1 | 单元格2 || 单元格3 | 单元格4 | 不常用但可能会用到的标记 1. 代码块1234```pythonprint(&apos;代码块表示多行代码，使用```来开头和结尾代码块&apos;)print(&apos;语言标识可选，若有则可自动高亮代码元素&apos;)``` 2. 行内代码1这是行内代码 `echo 行内代码嵌入在某一行文本中 3. 一级标题1# 这是一级标题 4. 五级标题1##### 这是五级标题 5. 六级标题1###### 这是六级标题 6. 分割线1--- 7. 斜体1这是*斜体* 8. 删除线1这是~~删除线~~ 三、图床之前介绍了 Markdown 插入图片的方式： 1![任意图片名称](https://xx.xx/xx) 这里演示的链接是网络链接，其实也可以使用本地图片的的文件路径，形式如下： 1![任意图片名称](C:\Documents\sample.png) 四、Markdown 标记的典型使用标题 文章的顶层标题使用二级标题 每个小节的标题使用三级标题 小节中进一步分层组织时使用四级标题 尽量少用五级标题和六级标题，考虑用有序列表和无序列表代替 完全不用一级标题 粗体、斜体需要强调某处内容时使用粗体。在中文排版中不使用斜体。在英文排版中可用斜体表达强调，或表示书名、题目。 引用以下情况使用引用标记： 引述内容时（也可直接用引号替代） 作示例时 给出提示、警告等额外说明时 行内代码、代码块1`echo 'Hello World' 图片Markdown 中使用1![图片名称](https://xx.xx/xx) 来插入图片，这里的「图片名称」可以任取，但是推荐使用对图片主题具有描述性的文字。因为在一些网站或软件中，图片无法加载时会显示这个「图片名称」，这时至少还能给读者传递出一点有用信息。 六、结语前面总共介绍了 18 种 Markdown 标记，其实常用的也就 10 种左右，这些标记符号都很简单，不出二十分钟便能全部记住。以后在写作的时候请尽量去使用 Markdown，一方面反复的练习会使你牢牢记住各种标记符号，使用时信手拈来；另一方面，Markdown 的使用会大大方便你写作，减少排版带来的负担。请坚信 Markdown 会为你带来生产力的提升。 学习自知乎，代码之外的自我修养专栏，作者黄浮云]]></content>
      <categories>
        <category>其他</category>
        <category>其他语言</category>
      </categories>
      <tags>
        <tag>CS</tag>
        <tag>攻略</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[function testing]]></title>
    <url>%2F2019-07-27-function-testing.html</url>
    <content type="text"><![CDATA[123456789101112131415#include &lt;ctime&gt;#include &lt;cmath&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;int main() &#123; ios::sync_with_stdio(false); string s; s = "Hello World！"; cout &lt;&lt; s &lt;&lt; endl; return 0;&#125;]]></content>
      <categories>
        <category>just_for_testing</category>
      </categories>
      <tags>
        <tag>just_for_testing</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019-07-26-MyFirstBlog.html</url>
    <content type="text"><![CDATA[Simulated-Anneal, this is your new start.]]></content>
  </entry>
</search>
