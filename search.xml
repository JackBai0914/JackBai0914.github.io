<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[[Codeforces]CR576 比赛记录]]></title>
    <url>%2F2019-08-03-Codeforces-CR576.html</url>
    <content type="text"><![CDATA[Codeforces Round #576 (Div. 1)1. General Info Problem: ABCD solved, EF unread. Ranking: 167 out of 662. Rating: 2179 -&gt; 2221 (+42). Summary: Mistakenly understood A at first, and wasted two submissions. Solved C, a constructive task based on Independent Set and Node Matching. Wasted too much time on D, a brute force with a trivial feature. 2. ProblemsA. MP3Statement: Given n intergers, calculate the maximum numbers of integers we can get by choosing m consecutive values inputed. Tutorial: In the contest, I used Two Pointers to go through the sorted sequence. Yet, we can transformed the array into value-indexed form and calculated the prefix. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cmath&gt;#include &lt;cstring&gt;#include &lt;ctime&gt;#include &lt;vector&gt;using namespace std;typedef long long ll;int n, I, a[1000010];int L;vector &lt;int&gt; v;int pans = 0, fans = 0;int main()&#123; ios::sync_with_stdio(false); cin &gt;&gt; n &gt;&gt; I; for (int i = 1; i &lt;= n; i ++) cin &gt;&gt; a[i]; (I *= 8) /= n; if (I &gt; 30) &#123; cout &lt;&lt; 0 &lt;&lt; endl; return 0; &#125; L = (1 &lt;&lt; I); int mx = 0; sort(a + 1, a + n + 1); for (int i = 1; i &lt;= n; i ++) &#123; int j = i; while (j + 1 &lt;= n &amp;&amp; a[j + 1] == a[i]) j ++; int num = j - i + 1; v.push_back(num); pans += num; if (v.size() &gt; L) pans -= v[v.size() - 1 - L]; // cerr &lt;&lt; num &lt;&lt; " " &lt;&lt; pans &lt;&lt; endl; fans = max (fans, pans); i = j; &#125; cout &lt;&lt; n - fans &lt;&lt; endl; return 0;&#125; B. Welfare StateStatement: Given a array of n integers, support two operations: 1) modify one value. 2) input v, apply a_i = max (a_i, v) to every i. Output the value of every integers in the end. Tutorial: In the contest, I coded a SegTree with lazy mark within 10 minutes, achieving $O(nlogn)$ time. However, noticing that only one Option 2 will be useful and Option 1&amp;2 wouldn’t influence each other, we can calculate options independentely and combine them in the end. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cmath&gt;#include &lt;cstring&gt;#include &lt;ctime&gt;#include &lt;vector&gt;using namespace std;typedef long long ll;int n, q;int ins[200020];typedef struct node &#123; int st, ed; node *l, *r; int lz, v; node (int stt, int edd, int lzz, int vv, node *L, node *R) &#123; st = stt, ed = edd, lz = -1, v = vv, l = L, r = R; &#125;&#125; *pnode;pnode build (int st, int ed) &#123; if (st == ed) &#123; pnode ne = new node (st, ed, 0, ins[st], 0, 0); return ne; &#125; int mid = (st + ed) &gt;&gt; 1; pnode ne = new node (st, ed, 0, 0, build (st, mid), build (mid + 1, ed)); return ne;&#125;void down (pnode r) &#123; if (!r || !r-&gt;l) return ; if (r-&gt;lz != -1) &#123; r-&gt;l-&gt;lz = max (r-&gt;l-&gt;lz, r-&gt;lz); r-&gt;r-&gt;lz = max (r-&gt;r-&gt;lz, r-&gt;lz); r-&gt;l-&gt;v = max (r-&gt;l-&gt;v, r-&gt;lz); r-&gt;r-&gt;v = max (r-&gt;r-&gt;v, r-&gt;lz); r-&gt;lz = -1; &#125;&#125;void cover (pnode r, int st, int ed, int v) &#123; if (st &lt;= r-&gt;st &amp;&amp; r-&gt;ed &lt;= ed) &#123; r-&gt;lz = max (r-&gt;lz, v); r-&gt;v = max (r-&gt;v, v); return ; &#125; down (r); if (st &lt;= r-&gt;l-&gt;ed) cover (r-&gt;l, st, ed, v); if (r-&gt;r-&gt;st &lt;= ed) cover (r-&gt;r, st, ed, v); return ;&#125;void modify (pnode r, int p, int v) &#123; if (r-&gt;st == r-&gt;ed) &#123; r-&gt;v = v; return ; &#125; down (r); if (p &lt;= r-&gt;l-&gt;ed) modify(r-&gt;l, p, v); if (r-&gt;r-&gt;st &lt;= p) modify(r-&gt;r, p, v); return ;&#125;void order (pnode r) &#123; if (r-&gt;st == r-&gt;ed) &#123; cout &lt;&lt; r-&gt;v &lt;&lt; " "; return ; &#125; down (r); order(r-&gt;l); order(r-&gt;r);&#125;int main()&#123; ios::sync_with_stdio(false); cin &gt;&gt; n; for (int i = 1; i &lt;= n; i ++) cin &gt;&gt; ins[i]; pnode root = build (1, n); cin &gt;&gt; q; for (int i = 1; i &lt;= q; i ++) &#123; int tp, a, b; cin &gt;&gt; tp; if (tp == 1) &#123; cin &gt;&gt; a &gt;&gt; b; modify(root, a, b); &#125; if (tp == 2) &#123; cin &gt;&gt; a; cover (root, 1, n, a); &#125; &#125; order(root); cout &lt;&lt; endl; return 0;&#125; C. Matching vs Independent SetStatement: Given a graph with 3*n vertices and m edges, find either a matching of n edges, or an independent set of n vertices. Tutorial: Calculating the Maximum Independent Set and the Maximum Matching of a graph both have high time complexity, so we need to think about the unique feature of this task. 3*n vertices are the strongest hint. We add edges to a matching greedily till no new edge can be added. Then, it’s easy to see we must achieved one of the conditions. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cmath&gt;#include &lt;cstring&gt;#include &lt;ctime&gt;#include &lt;vector&gt;using namespace std;typedef long long ll;int n, m;struct e &#123;int to, next;&#125; edge[5000050];int point[3000030], te = 0;void add (int u, int v) &#123; te ++; edge[te].to = v; edge[te].next = point[u]; point[u] = te;&#125;int flag[3000030];vector &lt;int&gt; rec;int cnt = 0;int main()&#123; ios::sync_with_stdio(false); int T; cin &gt;&gt; T; while (T --) &#123; te = 1; cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= 3 * n; i ++) point[i] = flag[i] = 0; for (int a, b, i = 1; i &lt;= m; i ++) &#123; cin &gt;&gt; a &gt;&gt; b; add (a, b);add (b, a); &#125; rec.resize(0); cnt = 0; for (int i = 1; i &lt;= 3 * n; i ++) &#123; if (flag[i]) continue ; for (int e = point[i]; e; e = edge[e].next) &#123; int to = edge[e].to; if (!flag[to]) &#123; flag[to] = flag[i] = 1; rec.push_back(e / 2); cnt ++; break; &#125; &#125; &#125; if (cnt &gt;= n) &#123; cout &lt;&lt; "Matching" &lt;&lt; '\n'; for (int i = 0; i &lt; n; i ++) cout &lt;&lt; rec[i] &lt;&lt; " "; cout &lt;&lt; '\n'; &#125; else &#123; int ans = 0; cout &lt;&lt; "IndSet" &lt;&lt; '\n'; for (int i = 1; i &lt;= 3 * n &amp;&amp; ans &lt; n; i ++) if (!flag[i]) &#123; cout &lt;&lt; i &lt;&lt; ' '; ans ++; &#125; cout &lt;&lt; '\n'; &#125; &#125; return 0;&#125; D. Rectangle Painting 1Statement: A square grid of size nn ($n \leq 50$) has some cells colored in black. Colored a rectangle of size h w into white requires $max(h, w)$ costs. Calculate the miminum cost to whiten the whole grid. Tutorial: The necessary condition of costing less than n is to leave one column uncovered. This feature suggests us to use DP on rectangles, with $O(n^4)$ states and $O(n)$ time to calculate one state, enumerating the missing column. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;#include &lt;ctime&gt;#include &lt;queue&gt;#include &lt;vector&gt;#include &lt;set&gt;#define TIME (double)clock()/CLOCKS_PER_SECusing namespace std;typedef long long ll;int n;int mp[55][55];int sum[55][55], s[2][55][55];int rec[55][55][55][55];int dfs (int stx, int sty, int edx, int edy) &#123; if (edx &lt; stx || edy &lt; sty) return 0; if (~rec[stx][sty][edx][edy]) return rec[stx][sty][edx][edy]; if (sum[edx][edy] - sum[stx - 1][edy] - sum[edx][sty - 1] + sum[stx - 1][sty - 1] == 0) &#123; rec[stx][sty][edx][edy] = 0; return 0; &#125; rec[stx][sty][edx][edy] = max (edx - stx + 1, edy - sty + 1); for (int x = stx; x &lt;= edx; x ++) &#123; if (s[0][x][edy] - s[0][x][sty - 1] != 0) continue ; rec[stx][sty][edx][edy] = min (rec[stx][sty][edx][edy], dfs (stx, sty, x - 1, edy) + dfs (x + 1, sty, edx, edy)); if (dfs (stx, sty, x - 1, edy) &gt;= rec[stx][sty][edx][edy]) break; &#125; for (int y = sty; y &lt;= edy; y ++) &#123; if (s[1][edx][y] - s[1][stx - 1][y] != 0) continue ; rec[stx][sty][edx][edy] = min (rec[stx][sty][edx][edy], dfs (stx, sty, edx, y - 1) + dfs (stx, y + 1, edx, edy)); if (dfs (stx, sty, edx, y - 1) &gt;= rec[stx][sty][edx][edy]) break; &#125; return rec[stx][sty][edx][edy];&#125;int main() &#123; cin &gt;&gt; n; for (int i = 1; i &lt;= n; i ++) for (int j = 1; j &lt;= n; j ++) &#123; char c; cin &gt;&gt; c; mp[i][j] = (c == '#' ? 1 : 0); sum[i][j] = mp[i][j] + sum[i][j - 1] + sum[i - 1][j] - sum[i - 1][j - 1]; s[0][i][j] = s[0][i][j - 1] + mp[i][j]; s[1][i][j] = s[1][i - 1][j] + mp[i][j]; &#125; memset(rec, -1, sizeof rec); cout &lt;&lt; dfs (1, 1, n, n) &lt;&lt; endl; // cerr &lt;&lt; TIME &lt;&lt; endl; return 0;&#125; E. Rectangle Painting 2Statement: A square grid of size nn ($n \leq 10^9$) has some cells colored in black， which are the union of m ($m \leq 50$) rectangles. Colored a rectangle of size h w into white requires $min(h, w)$ costs. Calculate the miminum cost to whiten the whole grid. Tutorial: Couldn’t find an easier Flow problem… The unwritten feature of this problem is that we are actually choosing columns and rows. As we construct a bipartite graph, we want to find the minimal vertex cover, which equals to the Maximum Flow. The only thing left is to compress identical vertices, to discretize the grid. 12 F. GCD Groups 2Statement: Given an array of n ($2 \leq n \leq 10^5$) integers, splite them into two groups so that the GCDs of both groups equal to one. Tutorial: The vital feature to open this problem is that each number has no more than k=9 divisors. If the answer is YES, every number could be put into a group with size no more than 9, because at most 9 numbers are vital to keep GCD down to 1. First, we randomly selected two numbers and assert them to be in different groups. The failing possibility of this step is negligible. Then, it’s easy to construct a subset DP with $O(n*2^{2k})$ complexity. Only $2^{2k}$ states are important to reduce the GCD down to 1. Observing closer, we find that we only need no more than 2*k candidates for each prime. Therefore, we pre-calculated the relationship between n numbers and k primes, and reduced the complexity of DP to $O(nk + k^22^{2k})$. The code below is randomization + greedy. Don’t ask my why…It’s neat. :D The idea of only choosing useful elements, as implemented below, is also non-trivial. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;#include &lt;ctime&gt;#include &lt;queue&gt;#include &lt;vector&gt;#include &lt;set&gt;#define F first#define S second#define MP make_pair#define TIME (double)clock()/CLOCKS_PER_SECusing namespace std;int gcd (int a, int b) &#123;if (!a||!b)return a+b; return gcd (b, a % b);&#125;int n;pair &lt;int, int&gt; a[1000010];int bel[1000010];bool fail() &#123; int g = 0; for (int i = 1; i &lt;= n; i ++) g = gcd (g, a[i].F); return (g != 1);&#125;int main() &#123; ios::sync_with_stdio(false); cin &gt;&gt; n; for (int v, i = 1; i &lt;= n; i ++) cin &gt;&gt; v, a[i] = MP(v, i); if (fail()) &#123; cout &lt;&lt; "NO" &lt;&lt; endl; return 0; &#125; int CNT = 0; while (true) &#123; if (((++CNT)&amp;127)==0 &amp;&amp; TIME &gt; 0.45)&#123; cout &lt;&lt; "NO" &lt;&lt; endl; // cerr &lt;&lt; "loop TIME: " &lt;&lt; CNT &lt;&lt; endl; return 0; &#125; random_shuffle(a + 1, a + n + 1); int g1 = 0, g2 = 0; for (int i = 1; i &lt;= n; i ++) &#123; int pre = gcd (g1, a[i].F); if (pre != g1) g1 = pre, bel[a[i].S] = 1; else g2 = gcd (g2, a[i].F), bel[a[i].S] = 2; &#125; if (g1 == 1 &amp;&amp; g2 == 1) &#123; cout &lt;&lt; "YES" &lt;&lt; endl; for (int i = 1; i &lt;= n; i ++) cout &lt;&lt; bel[i] &lt;&lt; ' '; cout &lt;&lt; endl; return 0; &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>Online Competitions</category>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>Computer Science</tag>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Markdown使用攻略]]></title>
    <url>%2F2019-07-28-Markdown%E4%BD%BF%E7%94%A8%E6%94%BB%E7%95%A5.html</url>
    <content type="text"><![CDATA[前置技能：Markdown一、Markdown 是什么Markdown 是一种标记语言。在写作时，你的所有文字都是没有样式的纯文本，在其中插入若干 Markdown 标记后，被标记的文字便有了样式。样式将会在渲染的时候呈现，并且样式的显示效果由 Markdown 工具决定。 比如，在你所写的文字中，你希望某一行的最终排版呈现一级标题的样式，那就给这行文字加个一级标题的标记；某个地方有两个字需要加粗，那就给这两个字加个粗体标记，最终的排版效果中这两字就会是粗体模样。 二、Markdown 的使用方法前面说了，Markdown 其实就是给文章内容作标记，把某处内容标记成什么那它最终就呈现对应的样式，而这些标记是一些简单的符号。 那 Markdown 标记都有哪些，样式效果是怎么的呢？ 常用的标记 1. 二级标题1## 这是二级标题 2. 三级标题1### 这是三级标题 3. 四级标题1#### 这是四级标题 4. 粗体1这是**粗体** 5. 引用1&gt; 这是引用 6. 有序列表1234Markdown 中列表有两种：1. 有序列表，像这样带序号的。其写法是：每项的序号以数字、点、空格组成2. 无序列表，不带序号的，也就是后面那种 7. 无序列表123456无序列表有两种相同效果的写法：* 用 * 和一个空格开头- 用 - 和一个空格开头一个列表中我们应该始终用同一种写法，不用混用 * 和 - 8. 链接1[这是链接文本](https://xx.xx/xx) 9. 插入图片1![任意图片名称](https://picture-gallery.oss-cn-shanghai.aliyuncs.com/markdown/markdown_logo.png) 10. 插入表格1234| 表头1 | 表头2 || --- | --- || 单元格1 | 单元格2 || 单元格3 | 单元格4 | 不常用但可能会用到的标记 1. 代码块1234```pythonprint(&apos;代码块表示多行代码，使用```来开头和结尾代码块&apos;)print(&apos;语言标识可选，若有则可自动高亮代码元素&apos;)``` 2. 行内代码1这是行内代码 `echo 行内代码嵌入在某一行文本中 3. 一级标题1# 这是一级标题 4. 五级标题1##### 这是五级标题 5. 六级标题1###### 这是六级标题 6. 分割线1--- 7. 斜体1这是*斜体* 8. 删除线1这是~~删除线~~ 三、图床之前介绍了 Markdown 插入图片的方式： 1![任意图片名称](https://xx.xx/xx) 这里演示的链接是网络链接，其实也可以使用本地图片的的文件路径，形式如下： 1![任意图片名称](C:\Documents\sample.png) 四、Markdown 标记的典型使用标题 文章的顶层标题使用二级标题 每个小节的标题使用三级标题 小节中进一步分层组织时使用四级标题 尽量少用五级标题和六级标题，考虑用有序列表和无序列表代替 完全不用一级标题 粗体、斜体需要强调某处内容时使用粗体。在中文排版中不使用斜体。在英文排版中可用斜体表达强调，或表示书名、题目。 引用以下情况使用引用标记： 引述内容时（也可直接用引号替代） 作示例时 给出提示、警告等额外说明时 行内代码、代码块1`echo 'Hello World' 图片Markdown 中使用1![图片名称](https://xx.xx/xx) 来插入图片，这里的「图片名称」可以任取，但是推荐使用对图片主题具有描述性的文字。因为在一些网站或软件中，图片无法加载时会显示这个「图片名称」，这时至少还能给读者传递出一点有用信息。 六、结语前面总共介绍了 18 种 Markdown 标记，其实常用的也就 10 种左右，这些标记符号都很简单，不出二十分钟便能全部记住。以后在写作的时候请尽量去使用 Markdown，一方面反复的练习会使你牢牢记住各种标记符号，使用时信手拈来；另一方面，Markdown 的使用会大大方便你写作，减少排版带来的负担。请坚信 Markdown 会为你带来生产力的提升。 学习自知乎，代码之外的自我修养专栏，作者黄浮云]]></content>
      <categories>
        <category>其他</category>
        <category>其他语言</category>
      </categories>
      <tags>
        <tag>Computer Science</tag>
        <tag>攻略</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[function testing]]></title>
    <url>%2F2019-07-27-function-testing.html</url>
    <content type="text"><![CDATA[123456789101112131415#include &lt;ctime&gt;#include &lt;cmath&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;int main() &#123; ios::sync_with_stdio(false); string s; s = "Hello World！"; cout &lt;&lt; s &lt;&lt; endl; return 0;&#125;]]></content>
      <categories>
        <category>just_for_testing</category>
      </categories>
      <tags>
        <tag>just_for_testing</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019-07-26-MyFirstBlog.html</url>
    <content type="text"><![CDATA[Simulated-Anneal, this is your new start.]]></content>
  </entry>
</search>
